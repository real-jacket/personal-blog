[{"categories":["JS"],"content":"这片文章研究 js 的时间循环机制！","date":"2018-10-29","objectID":"/posts/event-loop%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AFget/","tags":["JS"],"title":"Event Loop事件循环，GET！","uri":"/posts/event-loop%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AFget/"},{"categories":["JS"],"content":"JS 中比较让人头疼的问题之一要算异步事件了，比如我们经常要等后台返回数据后进行 dom 操作，又比如我们要设置一个定时器完成特定的要求。在这些同步与异步事件里，异步事件肯定是在同步事件之后的，但是异步事件之间又是怎么样的一个顺序呢，比如多个 setTimeout 事件又是怎么样一个执行顺序？这就涉及到事件循环：Event Loop。 ","date":"2018-10-29","objectID":"/posts/event-loop%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AFget/:0:0","tags":["JS"],"title":"Event Loop事件循环，GET！","uri":"/posts/event-loop%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AFget/"},{"categories":["JS"],"content":"JS 的单线程 虽然现在的 JS 可以用来做多方面的开发，但是最初的 JS 是浏览器的专用语言，用来操作 DOM。所以从诞生之初，JS 就被设计成单线程语言，原因是不想让浏览器变得太复杂，因为多线程需要共享资源、且有可能修改彼此的运行结果，对于一种网页脚本语言来说，这就太复杂了。如果 JavaScript 同时有两个线程，一个线程在网页 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？是不是还要有锁机制？所以，为了避免复杂性，JavaScript 一开始就是单线程，这已经成了这门语言的核心特征，将来也不会改变。 但是这种单线程机制却制造了另一个麻烦，假如一个操作需花费很长时间，那么此时浏览器就会一直等待这个操作完成，就会造成不好的体验。因此，JS 的另一个事件就是异步事件。异步事件是专门将一些事件以队列的形式储存到浏览器的任务队列中，等同步事件执行完后再去执行，这样就避免了页面堵塞。 JavaScript 引擎怎么知道异步任务有没有结果，能不能进入主线程呢？答案就是引擎在不停地检查，一遍又一遍，只要同步任务执行完了，引擎就会去检查那些挂起来的异步任务，是不是可以进入主线程了。这种循环检查的机制，就叫做事件循环（Event Loop）。 ","date":"2018-10-29","objectID":"/posts/event-loop%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AFget/:1:0","tags":["JS"],"title":"Event Loop事件循环，GET！","uri":"/posts/event-loop%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AFget/"},{"categories":["JS"],"content":"浏览器的事件循环 执行过程中栈的变化 如上图所示，js 中的基本数据与对象都会储存在栈内存中，其中复杂类型数据对象会在堆内存储存其数据结构，栈内存储存的是对这个数据结构的引用。 ","date":"2018-10-29","objectID":"/posts/event-loop%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AFget/:2:0","tags":["JS"],"title":"Event Loop事件循环，GET！","uri":"/posts/event-loop%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AFget/"},{"categories":["JS"],"content":"执行栈 javaScript 是单线程，也就是说只有一个主线程，主线程有一个栈。当 JS 代码执行时，代码会被推入执行栈中进行运行，运行代码的过程中，同步事件会立即执行，其中 Dom、Ajax 以及 SetTimeout 等异步事件会注册回调函数，放入事件回调队列中，等同步代码执行完之后执行。这样一个循环便是浏览器的 Event Loop。 执行过程中栈的变化 ","date":"2018-10-29","objectID":"/posts/event-loop%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AFget/:2:1","tags":["JS"],"title":"Event Loop事件循环，GET！","uri":"/posts/event-loop%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AFget/"},{"categories":["JS"],"content":"异步过程 但是在回调队列中这些事件又是怎么样一个执行顺序呢？实际上异步队列存在两个队列，一个宏任务队列，一个微任务队列，其这就涉及到两个概念: 宏任务(MacroTask): 包括整体代码 script，setTimeout、setInterval、setImmediate、I/O、UI 渲染 微任务(MicroTask)： Promise、process.nextTick、Object.observe、MutationObserver 在栈内存中代码执行完后，浏览器空闲，立即处理回调队列，将回调队列中的宏任务队列中的事件推入执行栈中执行。 首先会执行宏任务，如果宏任务中存在宏任务，则会把该任务放到宏任务队列中。如果该任务里存在微任务，则把微任务放在微任务队列。 在这个宏任务执行完后，首先去看微任务队列中是否有任务，然后把微任务推到执行栈中执行。 执行完微任务队列，这一次循环就结束了，然后再进行在宏任务队列中进行下一个宏任务，微任务，直至回调队列清空。 上述事件归纳后，以下例说明： 代码示例 分析： 循环 1： 【task 队列：script ；microtask 队列：】 1.首先整个代码被推到执行栈中执行，这是一个宏任务（整个 script 代码） 2.运行中，同步代码立即执行，new Promise 中的 fn 是立即执行的。setTimeout 被放在宏任务队列中，promise1、promise2 被放在微任务队列中。 【task 队列：setTimeout ；microtask 队列：promise1、promise2】 3.宏任务 script 执行完后，执行微任务队列，取出 microtask 队列，推入执行栈执行，第一次循环到此结束。 循环 2： 【task 队列：setTimeout ；microtask 队列：】 4.取出宏任务中的 setTimeout 推入执行栈执行，如果有微任务则，则被放在微任务队列（这里没有）。 5.宏任务执行完，去微任务队列执行（微任务队列为空）。 【task 队列：；microtask 队列：】 6.宏任务队列为空，循环至此结束。 ","date":"2018-10-29","objectID":"/posts/event-loop%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AFget/:2:2","tags":["JS"],"title":"Event Loop事件循环，GET！","uri":"/posts/event-loop%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AFget/"},{"categories":["JS"],"content":"Nodejs 事件循环 nodejs 中的事件循环跟浏览器不一样，浏览器的循环是遵循 ES 标准里的，nodejs 里的循环是通过 LIBUV 库实现的。 当 Node.js 启动时，会做这几件事 初始化 event loop 开始执行脚本（或者进入 REPL，本文不涉及 REPL）。这些脚本有可能会调用一些异步 API、设定计时器或者调用 process.nextTick() 开始处理 event loop nodejs 的 Event Loop 一共有 6 个阶段： ┌───────────────────────┐ ┌─\u003e│ timers │ │ └──────────┬────────────┘ │ ┌──────────┴────────────┐ │ │ I/O callbacks │ │ └──────────┬────────────┘ │ ┌──────────┴────────────┐ │ │ idle, prepare │ │ └──────────┬────────────┘ ┌───────────────┐ │ ┌──────────┴────────────┐ │ incoming: │ │ │ poll │\u003c─────┤ connections, │ │ └──────────┬────────────┘ │ data, etc. │ │ ┌──────────┴────────────┐ └───────────────┘ │ │ check │ │ └──────────┬────────────┘ │ ┌──────────┴────────────┐ └──┤ close callbacks │ └───────────────────────┘ 其中我们主要需要关注的是 timers、poll、check 阶段： timers 阶段：这个阶段执行 setTimeout 和 setInterval 的回调函数。 I/O callbacks 阶段：不在 timers 阶段、close callbacks 阶段和 check 阶段这三个阶段执行的回调，都由此阶段负责，这几乎包含了所有回调函数。 idle, prepare 阶段（译注：看起来是两个阶段，不过这不重要）：event loop 内部使用的阶段（译注：我们不用关心这个阶段） poll 阶段：获取新的 I/O 事件。在某些场景下 Node.js 会阻塞在这个阶段。 check 阶段：执行 setImmediate() 的回调函数。 close callbacks 阶段：执行关闭事件的回调函数，如 socket.on(‘close’, fn) 里的 fn。 ","date":"2018-10-29","objectID":"/posts/event-loop%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AFget/:3:0","tags":["JS"],"title":"Event Loop事件循环，GET！","uri":"/posts/event-loop%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AFget/"},{"categories":["JS"],"content":"timers 阶段 计时器实际上是在指定多久以后可以执行某个回调函数，而不是指定某个函数的确切执行时间。当指定的时间达到后，计时器的回调函数会尽早被执行。如果操作系统很忙，或者 Node.js 正在执行一个耗时的函数，那么计时器的回调函数就会被推迟执行。 ","date":"2018-10-29","objectID":"/posts/event-loop%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AFget/:3:1","tags":["JS"],"title":"Event Loop事件循环，GET！","uri":"/posts/event-loop%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AFget/"},{"categories":["JS"],"content":"poll 阶段（轮询阶段） poll 阶段有两个功能： 如果发现计时器的时间到了，就绕回到 timers 阶段执行计时器的回调。 然后再，执行 poll 队列里的回调。 当 event loop 进入 poll 阶段，如果发现没有计时器，就会： 如果 poll 队列不是空的，event loop 就会依次执行队列里的回调函数，直到队列被清空或者到达 poll 阶段的时间上限。 如果 poll 队列是空的，就会： 如果有 setImmediate() 任务，event loop 就结束 poll 阶段去往 check 阶段。 如果没有 setImmediate() 任务，event loop 就会等待新的回调函数进入 poll 队列，并立即执行它。 一旦 poll 队列为空，event loop 就会检查计时器有没有到期，如果有计时器到期了，event loop 就会回到 timers 阶段执行计时器的回调。 ","date":"2018-10-29","objectID":"/posts/event-loop%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AFget/:3:2","tags":["JS"],"title":"Event Loop事件循环，GET！","uri":"/posts/event-loop%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AFget/"},{"categories":["JS"],"content":"check 阶段 这个阶段允许开发者在 poll 阶段结束后立即执行一些函数。如果 poll 阶段空闲了，同时存在 setImmediate() 任务，event loop 就会进入 check 阶段，执行 setImmediate() 回调。 ","date":"2018-10-29","objectID":"/posts/event-loop%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AFget/:3:3","tags":["JS"],"title":"Event Loop事件循环，GET！","uri":"/posts/event-loop%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AFget/"},{"categories":["JS"],"content":"Event Loop 大体流程 每一个阶段都有一个队列，我们只关注 timers、poll、check 阶段来分析一下，我们在用命令行运行 node server.js 命令时，发生了什么： Node.js 启动，初始化 Event Loop 运行 server.js 脚本内容 开始运行 Event Loop timers 阶段看脚本里是否设置定时器 setTimeout，比如一个 4ms 延迟与一个 100ms 延迟的定时器，把它放到 timers 队列中，进入下一步，I/O callbacks 阶段，idle, prepare 阶段，这两个阶段都不会停留。 进入 poll（轮询）阶段，首先它会查看定时器时间是否到了，比如 4ms 到了，他就进入下一阶段 check 阶段、close callbacks 阶段，然后回到 timers 阶段执行设置的 4ms 回调函数，接着继续第 4 步到第 5 步。4ms 没到，则停留在这一阶段，处理 poll 队列里的任务，直到 4ms 到、100ms 到，然后循环回到 timers 阶段执行回调。 这里有一个问题：当 poll 阶段在处理任务 1 时，比如这个任务 1 要花费 100ms，在这 100ms 期间，setTimeout 定时器到了，则\u003e 它的回调会等 poll 处理玩任务 1 后立即循环进入 timers 阶段执行 从 poll 阶段进入 check 阶段时，主要是看是否有 setImmediate() 任务，如果有则立即执行，然后再进入 close callbacks 阶段，进行循环，进入 timers 阶段。 ","date":"2018-10-29","objectID":"/posts/event-loop%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AFget/:3:4","tags":["JS"],"title":"Event Loop事件循环，GET！","uri":"/posts/event-loop%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AFget/"},{"categories":["JS"],"content":"setImmediate() vs setTimeout() setImmediate 和 setTimeout 很相似，但是其回调函数的调用时机却不一样。 setImmediate() 的作用是在当前 poll 阶段结束后调用一个函数。 setTimeout() 的作用是在一段时间后调用一个函数。一般来说 setImmediate 会先于 setTimeout 执行，但是第一次启动的时候不一样，这两者的回调的执行顺序取决于 setTimeout 和 setImmediate 被调用时的环境。 例如: setTimeout(() =\u003e { console.log('setTimeout') }, 0) setImmediate(() =\u003e { console.log('setImmediate') }) 为什么会发生这种情况呢？因为我们启动 node.js 时, node 会做三件事, 初始化 event loop，运行脚本,开始 event loop。运行脚本与开始 event loop 这两件事不是同时执行的，它两中间间隔多少并不清楚，这跟环境性能有关。然后要注意的一点，setTimeout 的延迟时间最小为 4ms，所以这里的 0 相当于 4。 可能两者间隔 5ms，当进入 timers 阶段的时候，node 发现，4ms 已经过了，立即执行 setTimeout 定时器回调，然后执行 setImmediate。 也可能两者间隔 3ms，当进入 timers 阶段的时候，node 发现，4ms 还没过，就进入下一阶段，一直到 checked，执行 setImmediate，然后等到 4ms 时再执行 setTimeout。 ","date":"2018-10-29","objectID":"/posts/event-loop%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AFget/:3:5","tags":["JS"],"title":"Event Loop事件循环，GET！","uri":"/posts/event-loop%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AFget/"},{"categories":["JS"],"content":"process.nextTick() 从技术上来讲 process.nextTick() 并不是 event loop 的一部分。实际上，event loop 再次进入循环前，会去先执行 process.nextTick()。 setTimeout(() =\u003e { console.log('setTimeout') }, 0) setImmediate(() =\u003e { console.log('setImmediate') }) process.nextTick(() =\u003e { console.log('nextTick') }) 上述代码中 nextTick 先于其它两个执行，Vue 中有Vue.nextTick()方法就是类似的思想。 注： 本篇文章参考： Event Loop、计时器、nextTick 这一次，彻底弄懂 JavaScript 执行机制 从 event loop 规范探究 javaScript 异步及浏览器更新渲染时机 ","date":"2018-10-29","objectID":"/posts/event-loop%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AFget/:3:6","tags":["JS"],"title":"Event Loop事件循环，GET！","uri":"/posts/event-loop%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AFget/"},{"categories":[],"content":"http缓存机制","date":"2022-05-13","objectID":"/posts/index.zh/","tags":[],"title":"Http缓存","uri":"/posts/index.zh/"},{"categories":[],"content":"什么是缓存 通过复用以前获取的资源，可以显著提高网站和应用程序的性能。Web 缓存减少了等待时间和网络流量，因此减少了显示资源表示形式所需的时间。通过使用 HTTP缓存，变得更加响应性。 ","date":"2022-05-13","objectID":"/posts/index.zh/:1:0","tags":[],"title":"Http缓存","uri":"/posts/index.zh/"},{"categories":[],"content":"强制缓存 浏览器 \u003c=== 本地缓存 ===\u003e 服务器 Cache-Control：服务端控制 response headers 中 控制强制缓存的逻辑 例如 Cache-Control:max-age=3153600（单位是秒–一年） max-age 控制缓存的有效日期 no-cache 不用强制缓存，不管服务端处理 no-store 不用本地缓存，也不用服务端缓存 private 该响应是专用于某单个用户的，中间人不能缓存此响应，该响应只能应用于浏览器私有缓存中。 public 该响应可以被任何中间人（译者注：比如中间代理、CDN等）缓存。 Expires 同在 response headers 中 同为控制缓存过期 已被 Cache-Control 代替 ","date":"2022-05-13","objectID":"/posts/index.zh/:1:1","tags":[],"title":"Http缓存","uri":"/posts/index.zh/"},{"categories":[],"content":"协商缓存（对比缓存） 服务端缓存策略，服务端判断该资源能不能被缓存。 服务端判断客户端资源，是否和服务端一致 一致则返回304，否返回200和最新的资源 资源标识 在 response headers 中 Last-Modified 资源最后修改的时间 初次请求，服务端返回资源和 Last-Modified 再次请求的时候，request headers 带着 If-Modified-Since（与 Las-Modified 相同） 返回304，或者返回资源和新的 Last-Modified Etag 资源的唯一标识（一个字符串，类似人类的指纹 ） 同上，只是 换成了 Etag，对应的请求头应该为 If-None-Match 会优先使用 Etag Last-Modified 只能精确到秒级 如果资源被重新生成，而内容不变，则Etag更精确 ","date":"2022-05-13","objectID":"/posts/index.zh/:1:2","tags":[],"title":"Http缓存","uri":"/posts/index.zh/"},{"categories":[],"content":"缓存总结图 ","date":"2022-05-13","objectID":"/posts/index.zh/:2:0","tags":[],"title":"Http缓存","uri":"/posts/index.zh/"},{"categories":[],"content":"页面刷新操作 正常操作：强制缓存有效，协商缓存有效 手动刷新：强制缓存失效，协商缓存失效 强制刷新：强制缓存失效，协商缓存失效 ","date":"2022-05-13","objectID":"/posts/index.zh/:3:0","tags":[],"title":"Http缓存","uri":"/posts/index.zh/"},{"categories":["工具"],"content":"配置一个高效、美观、易用的 unix 命令行，极大提高你的效率","date":"2022-03-27","objectID":"/posts/oh-my-zsh%E4%BD%A0%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%AE%A9%E4%BA%BA%E4%B8%8D%E6%95%A2%E7%9B%B8%E4%BF%A1/","tags":["zsh","工具"],"title":"oh my zsh！你的命令行让人不敢相信","uri":"/posts/oh-my-zsh%E4%BD%A0%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%AE%A9%E4%BA%BA%E4%B8%8D%E6%95%A2%E7%9B%B8%E4%BF%A1/"},{"categories":["工具"],"content":"前置条件 zsh 只支持 类unix系统，不支持windows，windows用户想要体验，请在WSL中尝试！ ","date":"2022-03-27","objectID":"/posts/oh-my-zsh%E4%BD%A0%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%AE%A9%E4%BA%BA%E4%B8%8D%E6%95%A2%E7%9B%B8%E4%BF%A1/:1:0","tags":["zsh","工具"],"title":"oh my zsh！你的命令行让人不敢相信","uri":"/posts/oh-my-zsh%E4%BD%A0%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%AE%A9%E4%BA%BA%E4%B8%8D%E6%95%A2%E7%9B%B8%E4%BF%A1/"},{"categories":["工具"],"content":"安装 ","date":"2022-03-27","objectID":"/posts/oh-my-zsh%E4%BD%A0%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%AE%A9%E4%BA%BA%E4%B8%8D%E6%95%A2%E7%9B%B8%E4%BF%A1/:2:0","tags":["zsh","工具"],"title":"oh my zsh！你的命令行让人不敢相信","uri":"/posts/oh-my-zsh%E4%BD%A0%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%AE%A9%E4%BA%BA%E4%B8%8D%E6%95%A2%E7%9B%B8%E4%BF%A1/"},{"categories":["工具"],"content":"zsh安装 首先安装 Z shell，通过 zsh --version 判断是否安装 安装 Z shell sudo apt install zsh 设置为默认的bash chsh -s $(which zsh) 然后重启终端通过 echo $SHELL 确认默认终端（这个不一定有用，可能已经默认成功但是还是显示的 bash） ","date":"2022-03-27","objectID":"/posts/oh-my-zsh%E4%BD%A0%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%AE%A9%E4%BA%BA%E4%B8%8D%E6%95%A2%E7%9B%B8%E4%BF%A1/:2:1","tags":["zsh","工具"],"title":"oh my zsh！你的命令行让人不敢相信","uri":"/posts/oh-my-zsh%E4%BD%A0%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%AE%A9%E4%BA%BA%E4%B8%8D%E6%95%A2%E7%9B%B8%E4%BF%A1/"},{"categories":["工具"],"content":"oh my zsh安装 两种安装方式： via curl sh -c \"$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\" via weget sh -c \"$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)\" ","date":"2022-03-27","objectID":"/posts/oh-my-zsh%E4%BD%A0%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%AE%A9%E4%BA%BA%E4%B8%8D%E6%95%A2%E7%9B%B8%E4%BF%A1/:2:2","tags":["zsh","工具"],"title":"oh my zsh！你的命令行让人不敢相信","uri":"/posts/oh-my-zsh%E4%BD%A0%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%AE%A9%E4%BA%BA%E4%B8%8D%E6%95%A2%E7%9B%B8%E4%BF%A1/"},{"categories":["工具"],"content":"PowerLine Fonts安装 大部分主题都需要这个字体的支持： ubuntu安装 sudo apt-get install fonts-powerline 在WSL安装，需要把字体安装在windows系统中: git clone https://github.com/powerline/fonts.git --depth=1 然后双击 install.ps1 文件自动安装字体，通过 powershell 运行脚本进行安装 在不同的终端中配置字体，选择一款 for Powerline 的字体即可 ","date":"2022-03-27","objectID":"/posts/oh-my-zsh%E4%BD%A0%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%AE%A9%E4%BA%BA%E4%B8%8D%E6%95%A2%E7%9B%B8%E4%BF%A1/:2:3","tags":["zsh","工具"],"title":"oh my zsh！你的命令行让人不敢相信","uri":"/posts/oh-my-zsh%E4%BD%A0%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%AE%A9%E4%BA%BA%E4%B8%8D%E6%95%A2%E7%9B%B8%E4%BF%A1/"},{"categories":["工具"],"content":"主题配置 默认主题都在 ./oh-my-zsh/thems 目录下 新增的主题应该拷贝主题文件,以 .zsh-theme 结尾的文件，放在 .oh-my-zsh/custom/themes 目录下 ","date":"2022-03-27","objectID":"/posts/oh-my-zsh%E4%BD%A0%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%AE%A9%E4%BA%BA%E4%B8%8D%E6%95%A2%E7%9B%B8%E4%BF%A1/:3:0","tags":["zsh","工具"],"title":"oh my zsh！你的命令行让人不敢相信","uri":"/posts/oh-my-zsh%E4%BD%A0%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%AE%A9%E4%BA%BA%E4%B8%8D%E6%95%A2%E7%9B%B8%E4%BF%A1/"},{"categories":["工具"],"content":"修改主题配置 有时候别人的不总是满足，需要我们自定义一下 修改命令行前缀, 主题文件里的，比如主题 bullet-train.zsh-theme 文件里的 Define order and content of prompt 就定义了命令行前缀的一些命名，修改对应模块下的函数就可以改变命名。 ","date":"2022-03-27","objectID":"/posts/oh-my-zsh%E4%BD%A0%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%AE%A9%E4%BA%BA%E4%B8%8D%E6%95%A2%E7%9B%B8%E4%BF%A1/:3:1","tags":["zsh","工具"],"title":"oh my zsh！你的命令行让人不敢相信","uri":"/posts/oh-my-zsh%E4%BD%A0%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%AE%A9%E4%BA%BA%E4%B8%8D%E6%95%A2%E7%9B%B8%E4%BF%A1/"},{"categories":["工具"],"content":"插件 ","date":"2022-03-27","objectID":"/posts/oh-my-zsh%E4%BD%A0%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%AE%A9%E4%BA%BA%E4%B8%8D%E6%95%A2%E7%9B%B8%E4%BF%A1/:4:0","tags":["zsh","工具"],"title":"oh my zsh！你的命令行让人不敢相信","uri":"/posts/oh-my-zsh%E4%BD%A0%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%AE%A9%E4%BA%BA%E4%B8%8D%E6%95%A2%E7%9B%B8%E4%BF%A1/"},{"categories":["工具"],"content":"安装插件 通过包管理模式： apt-get install 的方式导入插件 通过 git clone 的方式拷贝代码到 .oh-my-zsh/custom/plugins 目录。 然后在 .zshrc 文件里 plugins = (git zsh-autosuggestion) 加入对应的插件 ","date":"2022-03-27","objectID":"/posts/oh-my-zsh%E4%BD%A0%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%AE%A9%E4%BA%BA%E4%B8%8D%E6%95%A2%E7%9B%B8%E4%BF%A1/:4:1","tags":["zsh","工具"],"title":"oh my zsh！你的命令行让人不敢相信","uri":"/posts/oh-my-zsh%E4%BD%A0%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%AE%A9%E4%BA%BA%E4%B8%8D%E6%95%A2%E7%9B%B8%E4%BF%A1/"},{"categories":["工具"],"content":"常用插件 具体的安装方式请查看插件的github： zsh-autosuggestion 路径自动补全，官方自带插件，可以直接在~/.zshrc中配置 zsh-syntax-highlighting 命令语法高亮 常见git缩写命令 git-open打开远程仓库 web-search 直接在命令行搜索，例如： google node 会自动打开Google搜索node last-working-dir 打开终端时自动为上次退出时的目录(zsh 自带插件) encode base64编码转化插件 urltools 使用urlcode命令对url进行编码 wd 给常用文件目录标记，快速跳转到指定目录，比如：进入目录后, wd add web，该目录被标记成web，下次直接 wd web就可以进入到该目录。直接在配置文件里添加 小提示 关于 last-working-dir 插件，在 windows10 wsl 中，这个插件判断当前为 $HOME 则不会进行跳转，所以需要在 wsl 中设置一个启动目录非 $HOME 的，比如 ~ 目录 ","date":"2022-03-27","objectID":"/posts/oh-my-zsh%E4%BD%A0%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%AE%A9%E4%BA%BA%E4%B8%8D%E6%95%A2%E7%9B%B8%E4%BF%A1/:4:2","tags":["zsh","工具"],"title":"oh my zsh！你的命令行让人不敢相信","uri":"/posts/oh-my-zsh%E4%BD%A0%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%AE%A9%E4%BA%BA%E4%B8%8D%E6%95%A2%E7%9B%B8%E4%BF%A1/"},{"categories":["工具"],"content":"linux自带插件 autojump 实现快速跳转到目录，安装后查看 /usr/share/doc/autojump/README.Debian 文件进行配置，其实就是（zsh）将 . /usr/share/autojump/autojump.sh 写入 .zshrc (注意空格) bat代替cat，有语法高亮 ubuntu 系统建议采用 .deb packages 方式安装 从 github 下载 bat 最新的安装包 ，建议直接网页下载，然后copy到 wsl 。（注：apt-get 方式ubuntu 软件源有重名问题，需要软连接一下，会出问题，故没有采用。下载.deb 软件包，最好在windows 网页下载，curl 方式下载的包有问题。） 执行 sudo dpkg -i bat_0.15.4_amd64.deb 进行安装 ","date":"2022-03-27","objectID":"/posts/oh-my-zsh%E4%BD%A0%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%AE%A9%E4%BA%BA%E4%B8%8D%E6%95%A2%E7%9B%B8%E4%BF%A1/:4:3","tags":["zsh","工具"],"title":"oh my zsh！你的命令行让人不敢相信","uri":"/posts/oh-my-zsh%E4%BD%A0%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%AE%A9%E4%BA%BA%E4%B8%8D%E6%95%A2%E7%9B%B8%E4%BF%A1/"},{"categories":["工具"],"content":"文件配置 ","date":"2022-03-27","objectID":"/posts/oh-my-zsh%E4%BD%A0%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%AE%A9%E4%BA%BA%E4%B8%8D%E6%95%A2%E7%9B%B8%E4%BF%A1/:5:0","tags":["zsh","工具"],"title":"oh my zsh！你的命令行让人不敢相信","uri":"/posts/oh-my-zsh%E4%BD%A0%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%AE%A9%E4%BA%BA%E4%B8%8D%E6%95%A2%E7%9B%B8%E4%BF%A1/"},{"categories":["工具"],"content":".OH_MY_ZSH文件目录 zsh 文件目录 ","date":"2022-03-27","objectID":"/posts/oh-my-zsh%E4%BD%A0%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%AE%A9%E4%BA%BA%E4%B8%8D%E6%95%A2%E7%9B%B8%E4%BF%A1/:5:1","tags":["zsh","工具"],"title":"oh my zsh！你的命令行让人不敢相信","uri":"/posts/oh-my-zsh%E4%BD%A0%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%AE%A9%E4%BA%BA%E4%B8%8D%E6%95%A2%E7%9B%B8%E4%BF%A1/"},{"categories":["工具"],"content":".zshrc 文件 # If you come from bash you might have to change your $PATH. # export PATH=$HOME/bin:/usr/local/bin:$PATH # autojump setting . /usr/share/autojump/autojump.sh # Path to your oh-my-zsh installation. export ZSH=\"/home/xiaomu/.oh-my-zsh\" # Set name of the theme to load --- if set to \"random\", it will # load a random theme each time oh-my-zsh is loaded, in which case, # to know which specific one was loaded, run: echo $RANDOM_THEME # See https://github.com/ohmyzsh/ohmyzsh/wiki/Themes ZSH_THEME=\"robbyrussell\" # Set list of themes to pick from when loading at random # Setting this variable when ZSH_THEME=random will cause zsh to load # a theme from this variable instead of looking in $ZSH/themes/ # If set to an empty array, this variable will have no effect. # ZSH_THEME_RANDOM_CANDIDATES=( \"robbyrussell\" \"agnoster\" ) # Uncomment the following line to use case-sensitive completion. # CASE_SENSITIVE=\"true\" # Uncomment the following line to use hyphen-insensitive completion. # Case-sensitive completion must be off. _ and - will be interchangeable. # HYPHEN_INSENSITIVE=\"true\" # Uncomment the following line to disable bi-weekly auto-update checks. # DISABLE_AUTO_UPDATE=\"true\" # Uncomment the following line to automatically update without prompting. # DISABLE_UPDATE_PROMPT=\"true\" # Uncomment the following line to change how often to auto-update (in days). # export UPDATE_ZSH_DAYS=13 # Uncomment the following line if pasting URLs and other text is messed up. # DISABLE_MAGIC_FUNCTIONS=true # Uncomment the following line to disable colors in ls. # DISABLE_LS_COLORS=\"true\" # Uncomment the following line to disable auto-setting terminal title. # DISABLE_AUTO_TITLE=\"true\" # Uncomment the following line to enable command auto-correction. # ENABLE_CORRECTION=\"true\" # Uncomment the following line to display red dots whilst waiting for completion. # COMPLETION_WAITING_DOTS=\"true\" # Uncomment the following line if you want to disable marking untracked files # under VCS as dirty. This makes repository status check for large repositories # much, much faster. # DISABLE_UNTRACKED_FILES_DIRTY=\"true\" # Uncomment the following line if you want to change the command execution time # stamp shown in the history command output. # You can set one of the optional three formats: # \"mm/dd/yyyy\"|\"dd.mm.yyyy\"|\"yyyy-mm-dd\" # or set a custom format using the strftime function format specifications, # see 'man strftime' for details. # HIST_STAMPS=\"mm/dd/yyyy\" # Would you like to use another custom folder than $ZSH/custom? # ZSH_CUSTOM=/path/to/new-custom-folder # Which plugins would you like to load? # Standard plugins can be found in $ZSH/plugins/ # Custom plugins may be added to $ZSH_CUSTOM/plugins/ # Example format: plugins=(rails git textmate ruby lighthouse) # Add wisely, as too many plugins slow down shell startup. plugins=(git zsh-autosuggestions zsh-syntax-highlighting git-open web-search last-working-dir encode64 urltools wd) source $ZSH/oh-my-zsh.sh # User configuration # export MANPATH=\"/usr/local/man:$MANPATH\" # You may need to manually set your language environment # export LANG=en_US.UTF-8 # Preferred editor for local and remote sessions # if [[ -n $SSH_CONNECTION ]]; then # export EDITOR='vim' # else # export EDITOR='mvim' # fi # Compilation flags # export ARCHFLAGS=\"-arch x86_64\" # Set personal aliases, overriding those provided by oh-my-zsh libs, # plugins, and themes. Aliases can be placed here, though oh-my-zsh # users are encouraged to define aliases within the ZSH_CUSTOM folder. # For a full list of active aliases, run `alias`. # # Example aliases # alias zshconfig=\"mate ~/.zshrc\" # alias ohmyzsh=\"mate ~/.oh-my-zsh\" ","date":"2022-03-27","objectID":"/posts/oh-my-zsh%E4%BD%A0%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%AE%A9%E4%BA%BA%E4%B8%8D%E6%95%A2%E7%9B%B8%E4%BF%A1/:5:2","tags":["zsh","工具"],"title":"oh my zsh！你的命令行让人不敢相信","uri":"/posts/oh-my-zsh%E4%BD%A0%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%AE%A9%E4%BA%BA%E4%B8%8D%E6%95%A2%E7%9B%B8%E4%BF%A1/"},{"categories":["Web"],"content":"讲解了 v8 垃圾回收如何工作的","date":"2022-03-27","objectID":"/posts/v8-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/","tags":["v8","垃圾回收"],"title":"V8 垃圾回收","uri":"/posts/v8-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"},{"categories":["Web"],"content":"什么是垃圾回收 js 中基本类型是储存在栈空间里的，复杂类型是储存在堆空间里，同时栈空间里保存这对它的引用。这是数据的储存方式，如果这些数据被使用过后就不再被需要了，就成了我们常说的垃圾数据，就需要被清理掉。 当调用栈的函数执行完毕，会被弹出，同时销毁函数的执行上下文，就会导致内存里没用的数据成为垃圾数据，会被js 里的垃圾回收器进行自动回收。 ","date":"2022-03-27","objectID":"/posts/v8-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/:1:0","tags":["v8","垃圾回收"],"title":"V8 垃圾回收","uri":"/posts/v8-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"},{"categories":["Web"],"content":"代际假说 代际假说有两个特点： 第一个大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经内存分配。就很快变得不可访问 第二个是不死的对象，会活的更久 根据上述两个特性，v8 将堆内存分为两个区域，新生代与老生代： 新生代：存放生存时间较短的对象，通常支持1～8M大小的容量 老生代：存放生存时间较长的对象，比较大 根据上述两个区域，垃圾回收器也就分成里两种，主、副垃圾回收器： 副垃圾回收器：主要负责新生代垃圾的回收 主垃圾回收器：主要负责老生代的垃圾回收 ","date":"2022-03-27","objectID":"/posts/v8-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/:2:0","tags":["v8","垃圾回收"],"title":"V8 垃圾回收","uri":"/posts/v8-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"},{"categories":["Web"],"content":"垃圾回收的原理 ","date":"2022-03-27","objectID":"/posts/v8-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/:3:0","tags":["v8","垃圾回收"],"title":"V8 垃圾回收","uri":"/posts/v8-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"},{"categories":["Web"],"content":"执行流程 第一步是标记空间中活动对象何非活动对象。即还在使用的对象，可以进行垃圾回收的对象，即标记垃圾数据。 回收非活动对象所占据的内存。也就是垃圾清理阶段。 内存整理。垃圾回收后，内存里会出现大量不连续的小块内存，即内存碎片。不利于内存的利用，当需要大量连续内存比如数组时，就会导致内存不足。故需要在最后一步，对这些内存进行整理。 ","date":"2022-03-27","objectID":"/posts/v8-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/:3:1","tags":["v8","垃圾回收"],"title":"V8 垃圾回收","uri":"/posts/v8-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"},{"categories":["Web"],"content":"副垃圾回收器 主要负责新生代的垃圾回收，通常情况大部分小的对象都会被分配到新生区，会经常发生垃圾回收的区域。 新生代采用 Scavenge 算法进行处理。将新生代分为两个区域，一半为对象区域，一半为空闲区域。 新加入的对象都会被放在对象区域，等对象区域快满的时候，就会执行一次垃圾清理操作。 首先会对对象区域中的垃圾进行标记，标记完成会进入清理垃圾阶段 副垃圾回收器会将未标记的存活对象复制到空闲区域，同时还会对这些对象进行有序的排列，所以复制的过程同时完成里内存整理，复制后空闲区域就没有内存碎片 复制完成，对象区域与空闲区域角色翻转。原来的对象区域变成空闲区域，空闲区域变成对象区域，清空空闲区域，就这样完成垃圾回收。 由于会进行对象的复制操作，所以这块新生代内存不会太大，有错也会造成对象区域很容易被填满。为里解决这种问题， v8 采取里对晋升策略，经过两次垃圾回收依然存活的对象会被移动到老生区。 ","date":"2022-03-27","objectID":"/posts/v8-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/:3:2","tags":["v8","垃圾回收"],"title":"V8 垃圾回收","uri":"/posts/v8-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"},{"categories":["Web"],"content":"主垃圾回收器 主垃圾回收器主要负责老生生区的垃圾回收。除老新生区中晋生的对象，一些大的对象会直接被分配到老生区。因此老生区中有两个特点： 对象占用空间大 对象存活时间长 由于老生区对象比较大，就不能采用新生区的 Scavenge 算法进行垃圾回收。主垃圾回收器采用的是 标记 - 清除 的算法进行垃圾回收。 标记阶段：从一组根元素开始，递归遍历这组元素，在这个遍历的过程中，能达到的元素称为活动对象，没有达到的元素可以判断为垃圾对象 垃圾清除：对老生区中标记为垃圾的对象进行清理，在清理前首先会让活动对象向一段移动，然后直接清理掉端边界以外的内存。 ","date":"2022-03-27","objectID":"/posts/v8-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/:3:3","tags":["v8","垃圾回收"],"title":"V8 垃圾回收","uri":"/posts/v8-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"},{"categories":["Web"],"content":"全停顿 由于 js 是单线程的，并且与渲染线程同属一个，所以一旦执行垃圾回收，会暂停 js 脚本，待垃圾回收完毕再回复脚本执行。我们吧这种行为称之为全停顿。 在新生代中，由于空间较小，全停顿影响不大，但是老生代空间对象很大，就不能使用全停顿了。v8 为了减少这种停顿，将标记阶段分为一个个子标记阶段，标记与js逻辑交替执行，直至标记阶段完成。然后进行清理+整理的过程。 ","date":"2022-03-27","objectID":"/posts/v8-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/:4:0","tags":["v8","垃圾回收"],"title":"V8 垃圾回收","uri":"/posts/v8-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"},{"categories":null,"content":"Xiaomu ","date":"2022-03-26","objectID":"/about/:0:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"个人信息 基本信息：xiaomu 职位：前端开发工程师 微信号：ke1762982273 工作年限：3 年+ Github：https://github.com/real-jacket 语雀知识库：https://www.yuque.com/kanbudongdeni ","date":"2022-03-26","objectID":"/about/:1:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"技能清单 ","date":"2022-03-26","objectID":"/about/:2:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"掌握 HTML/CSS：深入理解浏览器相关原理，熟悉移动端开发，能够像素级实现业务需求。 JS/TS：熟练掌握 js/ts，了解常见的设计模式。 Vue/React：熟练使用相关框架，并对底层原理有一定了解。 前端工程化：熟悉常见的打包工具 webpack、rollup 等,了解 vite、lerna、pnpm 等工具。 Node：熟练使用 Node 进行 web 应用开发，了解常见数据库 mongodb、mysql 的基本使用。 总结：追求用户体验、喜欢研究效率工具、喜欢深挖原理，弄清问题本质，不断拓宽自己边界。 ","date":"2022-03-26","objectID":"/about/:2:1","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"在学 go web 容器化技术：Docker、k8s 等等 rust ","date":"2022-03-26","objectID":"/about/:2:2","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"工作经历 ","date":"2022-03-26","objectID":"/about/:3:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"上海喜马拉雅科技有限公司（2021.1～至今）高级前端开发工程师 独立负责公司会员业务方向及负责年度大促活动的相关开发工作。 公司营销活动搭建平台相关基建方向的建设。 ","date":"2022-03-26","objectID":"/about/:3:1","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"杭州屹创科技有限公司 （2018.11 ~ 2020.12）软件开发工程师 负责公司线下门店 yunpos 系统开发（pc）。 推动公司前端技术体系及规范的建立，独立负责公司多个全栈应用开发。 ","date":"2022-03-26","objectID":"/about/:3:2","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"联系 Notice 目前状态：求职中 可以通过评论留下公司 JD，我会及时投递 可以通过 wx 联系我,wx 号在页面顶部个人信息处 ","date":"2022-03-26","objectID":"/about/:4:0","tags":null,"title":"关于","uri":"/about/"},{"categories":["JS"],"content":"关于斐波那契数列 ","date":"2020-09-08","objectID":"/posts/%E5%85%B3%E4%BA%8E%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/:0:0","tags":["JS","function"],"title":"关于斐波那契数列","uri":"/posts/%E5%85%B3%E4%BA%8E%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"},{"categories":["JS"],"content":"斐波那契数列 JS 实现 // n 默认为大于零的整数 function fib(n) { if (n \u003c 2) { return n } else { return fib(n - 2) + fib(n - 1) } } 斐波那契数列函数的实现基本是基于 “递归” 的思想。但是递归会涉及到一个比较严重的问题 “性能”！ ","date":"2020-09-08","objectID":"/posts/%E5%85%B3%E4%BA%8E%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/:1:0","tags":["JS","function"],"title":"关于斐波那契数列","uri":"/posts/%E5%85%B3%E4%BA%8E%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"},{"categories":["JS"],"content":"性能分析 性能的主要问题是 “调用栈”，当我们递归调用函数的时候，上一个函数始终在执行栈内，无法弹出，导致调用栈不断增加，直到最后一个函数执行完毕，才会一个个一次回归弹出。 ","date":"2020-09-08","objectID":"/posts/%E5%85%B3%E4%BA%8E%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/:2:0","tags":["JS","function"],"title":"关于斐波那契数列","uri":"/posts/%E5%85%B3%E4%BA%8E%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"},{"categories":["JS"],"content":"优化 优化的点主要在降低压栈次数或者计算次数。 ","date":"2020-09-08","objectID":"/posts/%E5%85%B3%E4%BA%8E%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/:3:0","tags":["JS","function"],"title":"关于斐波那契数列","uri":"/posts/%E5%85%B3%E4%BA%8E%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"},{"categories":["JS"],"content":"尾递归优化 使用迭代代替递归，即尾递归。主要是在每次函数执行的时候弹出执行栈，返回一个新的函数继续后续执行，使得执行栈中始终只有一个函数。 function fib(n) { if (n \u003c 2) { return n } else { return fib_in(2, n, 1, 0) } } function fib_in(start, end, pre1, pre2) { return start === end ? pre1 + pre2 : fib_in(start + 1, end, pre1 + pre2, pre1) } ","date":"2020-09-08","objectID":"/posts/%E5%85%B3%E4%BA%8E%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/:3:1","tags":["JS","function"],"title":"关于斐波那契数列","uri":"/posts/%E5%85%B3%E4%BA%8E%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"},{"categories":["JS"],"content":"记忆函数 把递归改变成循环，对每次计算的结果进行缓存，避免斐波那契递归过程中大量的重复计算 function fib(n) { const arr = [0, 1] for (let i = 0; i \u003c n; i++) { arr[i + 2] = arr[i + 1] + arr[i] } return arr[n] } // 或者 function fib(n) { let pre1 = 0 let pre2 = 1 for (let i = 0; i \u003c n; i++) { temp = pre2 pre2 = pre1 + pre2 pre1 = temp } return pre1 } ","date":"2020-09-08","objectID":"/posts/%E5%85%B3%E4%BA%8E%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/:3:2","tags":["JS","function"],"title":"关于斐波那契数列","uri":"/posts/%E5%85%B3%E4%BA%8E%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"},{"categories":["JS"],"content":"延伸 我们优化斐波那契函数时，第二种方法是通过缓存结果来避免重复计算。同样的思想在 React 的优化中同样体现，React 的 memo 记忆函数，就是通过缓存相关变量，来避免组件的重复渲染。 ","date":"2020-09-08","objectID":"/posts/%E5%85%B3%E4%BA%8E%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/:4:0","tags":["JS","function"],"title":"关于斐波那契数列","uri":"/posts/%E5%85%B3%E4%BA%8E%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"},{"categories":["JS"],"content":"关于 this 的一道面试题 ","date":"2020-09-02","objectID":"/posts/%E5%85%B3%E4%BA%8Ethis%E7%9A%84%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98/:0:0","tags":["JS","this"],"title":"关于this的一道面试题","uri":"/posts/%E5%85%B3%E4%BA%8Ethis%E7%9A%84%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"categories":["JS"],"content":"问题 首先贴代码： let length = 10 function fn() { console.log(this.length) } let obj = { length: 5, method(fn) { fn() arguments[0]() }, } obj.method(fn, 1) 请问最后打印出什么？ 第一个 fn() 不确定是什么，一般为 0/undefined。 第二个 arguments[0]() 为 2，是函数调用的实参个数。 ","date":"2020-09-02","objectID":"/posts/%E5%85%B3%E4%BA%8Ethis%E7%9A%84%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98/:1:0","tags":["JS","this"],"title":"关于this的一道面试题","uri":"/posts/%E5%85%B3%E4%BA%8Ethis%E7%9A%84%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"categories":["JS"],"content":"分析 ","date":"2020-09-02","objectID":"/posts/%E5%85%B3%E4%BA%8Ethis%E7%9A%84%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98/:2:0","tags":["JS","this"],"title":"关于this的一道面试题","uri":"/posts/%E5%85%B3%E4%BA%8Ethis%E7%9A%84%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"categories":["JS"],"content":"函数的返回值是由什么决定的？ 调用时输入的参数 params 定义时的环境 env 那么 Js 函数调用时， obj.method(fn,1) 这个函数调用时，参数只有 fn 跟 1 么？ 隐式参数 arguments：传入函数所有参数（实参）的集合 this：执行上下文（就是一个对象），与函数调用相关联的对象，这个就跟定义时的环境有关。 显式参数括号内的参数: fn、1 ","date":"2020-09-02","objectID":"/posts/%E5%85%B3%E4%BA%8Ethis%E7%9A%84%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98/:2:1","tags":["JS","this"],"title":"关于this的一道面试题","uri":"/posts/%E5%85%B3%E4%BA%8Ethis%E7%9A%84%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"categories":["JS"],"content":"明确 this 的传入，将 this 显式化 由于 this 的模糊性，通过 call 转化将 this 显式传入： obj.method(fn,1) ===\u003e obj.method.call(obj,fn,1) fn() ===\u003e fn.call(undefined) // 这里默认为 this 为全局环境（window/global） arguments0 ===\u003e arguments[0].call(arguments) 由上面可以看出：三个函数调用，传入的 this 。 注意： 这里需要注意 fn 作为参数传进来，相当于进行了一次隐式赋值，即 var fn = fn。即函数内部的 fn 等与 外面的 fn。 ","date":"2020-09-02","objectID":"/posts/%E5%85%B3%E4%BA%8Ethis%E7%9A%84%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98/:2:2","tags":["JS","this"],"title":"关于this的一道面试题","uri":"/posts/%E5%85%B3%E4%BA%8Ethis%E7%9A%84%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"categories":["JS"],"content":"关于 let 变量声明 我们知道 var 声明的变量是全局变量，作用域为全局，通常挂在 window 下。let 声明的变量局部变量，mdn 中关于 let 是这么定义：“let 语句声明一个块级作用域的本地变量，并且可选的将其初始化为一个值。”但是如果在全局环境下进行 let 声明，这个变量会挂在 window 下么？在 mdn 中关于顶级环境的问题也给出了说明，“At the top level of programs and functions, let, unlike var, does not create a property on the global object.”说明不会挂载在 window 下。 ","date":"2020-09-02","objectID":"/posts/%E5%85%B3%E4%BA%8Ethis%E7%9A%84%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98/:2:3","tags":["JS","this"],"title":"关于this的一道面试题","uri":"/posts/%E5%85%B3%E4%BA%8Ethis%E7%9A%84%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"categories":["JS"],"content":"window.length 到底是什么 window.length 为当前页面中 ifram 的个数。 ","date":"2020-09-02","objectID":"/posts/%E5%85%B3%E4%BA%8Ethis%E7%9A%84%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98/:2:4","tags":["JS","this"],"title":"关于this的一道面试题","uri":"/posts/%E5%85%B3%E4%BA%8Ethis%E7%9A%84%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"categories":["JS"],"content":"延伸 let length = 10 function fn() { console.log(length) console.log(this.length) } let obj = { length: 5, method(fn) { let length = 3 fn() arguments[0]() console.log(this.length) console.log(length) }, } obj.method(fn, 1) ","date":"2020-09-02","objectID":"/posts/%E5%85%B3%E4%BA%8Ethis%E7%9A%84%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98/:3:0","tags":["JS","this"],"title":"关于this的一道面试题","uri":"/posts/%E5%85%B3%E4%BA%8Ethis%E7%9A%84%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"categories":["JS"],"content":"总结 函数调用时的 this 为该函数的执行上下文。 函数调用默认会隐式的传两个参数，this 与 arguments 在不清楚 this 时，将 this 显示的传入。 ","date":"2020-09-02","objectID":"/posts/%E5%85%B3%E4%BA%8Ethis%E7%9A%84%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98/:4:0","tags":["JS","this"],"title":"关于this的一道面试题","uri":"/posts/%E5%85%B3%E4%BA%8Ethis%E7%9A%84%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"categories":["Node"],"content":"Node 海报分享实践 最近做了一个 wx 的 node 端海报分享功能，记录一下其中功能的实现，实现一个 express 路由。 ","date":"2020-08-20","objectID":"/posts/node-%E6%B5%B7%E6%8A%A5%E5%8A%9F%E8%83%BD%E5%AE%9E%E8%B7%B5/:0:0","tags":["node"],"title":"Node 海报功能实践","uri":"/posts/node-%E6%B5%B7%E6%8A%A5%E5%8A%9F%E8%83%BD%E5%AE%9E%E8%B7%B5/"},{"categories":["Node"],"content":"使用技术 node-canvas: 主要用来绘制文字内容。 canvas-multiline-text: 一个用于绘制多行文字内容的第三方库。 sharp: 用于处理图片以及进行图片合成的库。 注意： canvas 与 sharp 由于网络限制需要 fq 下载，建议使用阿里镜像进行下载，这里推荐使用 tyarn 进行相关包下载。 ","date":"2020-08-20","objectID":"/posts/node-%E6%B5%B7%E6%8A%A5%E5%8A%9F%E8%83%BD%E5%AE%9E%E8%B7%B5/:1:0","tags":["node"],"title":"Node 海报功能实践","uri":"/posts/node-%E6%B5%B7%E6%8A%A5%E5%8A%9F%E8%83%BD%E5%AE%9E%E8%B7%B5/"},{"categories":["Node"],"content":"背景 常见的 wx 分享，一般而言主要目的是用来推广客户扫描参与活动，所以基本的核心在于三部分：海报背景、文案内容、推广二维码。 主要利用 canvas 进行相关绘制，需要明确相关图片与文字内容的相关坐标。这里是把相关内容与对应坐标，写在一个配置文件里。 坐标配置： const themes = { default: { background: 'bgc.jpg', title: { x: 100, y: 100, fontFamily: 'serif', color: 'red', fontSize: 40, fontStyle: 'italic', fontWeight: 'bold' }, // 标题 date: { x: 300, y: 300, fontFamily: 'serif', color: 'black', fontSize: 12, fontStyle: 'italic', fontWeight: 'bold', }, // 活动时间 content: { x: 400, y: 400, fontFamily: 'serif', color: '', fontSize: 12, fontStyle: 'italic', fontWeight: 'bold' }, // 活动内容 qrcode: { x: 500, y: 500, size: { width: 120, height: 120 } }, // 二维码大小与指定位置 copyright: { x: 600, y: 600, fontFamily: 'serif', color: '', fontSize: 12, fontStyle: 'italic', fontWeight: 'bold', }, // 版权说明 }, purple: { background: 'haibao_bg1.png', title: { fontFamily: 'SourceHanSansHWSC', color: 'white', fontSize: 44, fontStyle: 'normal', fontWeight: 'bold', x: 56, y: 294, }, // 标题 date: { x: 181, y: 363, fontFamily: 'SourceHanSansHWSC', color: 'white', fontSize: 16, fontStyle: 'normal', fontWeight: 'bold', }, // 活动时间 content: { fontFamily: 'SourceHanSansCN', color: 'white', fontSize: 11, fontStyle: 'normal', fontWeight: 'normal', x: 47, y: 687, size: { width: 503, height: 49.5 }, }, // 活动内容 qrcode: { x: 189, y: 424, size: { width: 218, height: 218 } }, // 二维码大小与指定位置 copyright: { x: 124, y: 798, fontFamily: 'SourceHanSansCN', color: 'white', fontSize: 11, fontStyle: 'normal', fontWeight: 'normal', }, // 版权说明 }, plain: { background: 'haibao_bg4.png', title: { offset: 356, fontFamily: 'SourceHanSansHWSC', color: '#FF165F', fontSize: 36, fontStyle: 'normal', fontWeight: 'bold', x: 402, y: 58, }, // 标题 date: { offset: 356, x: 488, y: 124, fontFamily: 'SourceHanSansHWSC', color: '#FF165F', fontSize: 16, fontStyle: 'normal', fontWeight: 'bold', }, // 活动时间 content: { offset: 356, fontFamily: 'SourceHanSansCN', color: '#FF165F', fontSize: 11, fontStyle: 'normal', fontWeight: 'normal', x: 401, y: 454, size: { width: 396, height: 66 }, }, // 活动内容 qrcode: { offset: 356, x: 490, y: 220, size: { width: 218, height: 218 } }, // 二维码大小与指定位置 copyright: { offset: 356, x: 491, y: 554, fontFamily: 'SourceHanSansCN', color: '#FF155D', fontSize: 11, fontStyle: 'normal', fontWeight: 'normal', }, // 版权说明 }, } module.exports = themes 接口调用的请求入参数： { \"theme\": \"plain\", \"title\": \"xxxx时代店有奖活动\", \"date\": \"时间：2020-08-27 ~ 2020-08-13\", \"content\": \"凡到xxxx时代店购买商品的用户，均有机会参与抽奖活动，一等奖价值79元的女鞋一双，20个中奖机会，二等奖价值59元女鞋一双，50个中奖机会\", \"qrcode\": \"data:image/png;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/2wBDAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/wAARCAEYARgDASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD+/iiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAPCv2jv2mvgN+yL8Kta+N37SXxP8M/CL4WeH7rT7DU/GHiq4mg0+PUtXn+y6VplvFawXV5falqVz+5srGytp7mdwxWPYjsu38Dfjt8IP2l/hb4U+NnwG+IHh34o/Crxxa3V54V8b+FbtrzRdYhsb+60u++zySRwzRzWWpWV3YXltcQw3Ftd200E0SOhFfyO/8HrvxC1XQf2FP2XfhzaRY0z4hftMXWravcrdXMLj/hBfh5r8thZvbRMLe8t7m48RtcyC5DeRPYWssID5Yfox/wAGrvhOHwx/wRW/Zouor3Vrx/F/ib40eLLmLVLgzxafNc/FXxRowstIQxxm10n7PokF5Fb5kH2y7vZxIROFUA/okoor+Nr/AIOWv+C8f7VH/BNL47/s/wD7O/7IN34I0TxJrnw+n+LnxS13xp4NtfGK3mlah4mutC8IeGdNt7+aK2srec+G/ENzrVxD/p8sN1ZRQS2e0TSgH9ktFeHfsx/EvxJ8Z/2cfgL8XfGHhyXwh4s+J/we+G/j/wASeF5lRZNB1zxd4Q0jXdU0zZHNcIiWl5fTRRIJ5tkSoplkILn3GgAooooAKKKKACiiigAooooAKKKKACiiigA","date":"2020-08-20","objectID":"/posts/node-%E6%B5%B7%E6%8A%A5%E5%8A%9F%E8%83%BD%E5%AE%9E%E8%B7%B5/:2:0","tags":["node"],"title":"Node 海报功能实践","uri":"/posts/node-%E6%B5%B7%E6%8A%A5%E5%8A%9F%E8%83%BD%E5%AE%9E%E8%B7%B5/"},{"categories":["Node"],"content":"合成图片 sharp 函数接受一个图片输入，参数为图片路径或者图片的 buffer 数据。 主要利用 sharp 的 composite API 进行图片合成， sharp().composite() 接受一个对象数组，这个对象我们最基本需要用到的三个属性； input : 需要合成的图片路径，或者图片的 buffer 数据 top ：合成图片在图片距离顶部的位移 left ：同上，合成图片距离图片左边的位移 // 根据 ajax 请求的 body，获取主题配置与海报文案，这里二维码是以 base64 的形式传输的 const { theme, qrcode, ...content } = req.body const imgUrl = path.resolve(__dirname, `../public/${config.background}`) // 合成图片 // 将 qrcode base64 图片 转化成 buffer const dataBuffer = Buffer.from(qrcode.replace(/^data:image\\/\\w+;base64,/, ''), 'base64') // 处理二维码 大小 const qrCodeBuffer = await sharp(dataBuffer).resize(config.qrcode.size.width, config.qrcode.size.height).toBuffer() // 开始合成二维码 const compositeImage = await sharp(imgUrl) .composite([ { input: qrCodeBuffer, top: config.qrcode.y, left: config.qrcode.x, }, ]) .toBuffer() ","date":"2020-08-20","objectID":"/posts/node-%E6%B5%B7%E6%8A%A5%E5%8A%9F%E8%83%BD%E5%AE%9E%E8%B7%B5/:3:0","tags":["node"],"title":"Node 海报功能实践","uri":"/posts/node-%E6%B5%B7%E6%8A%A5%E5%8A%9F%E8%83%BD%E5%AE%9E%E8%B7%B5/"},{"categories":["Node"],"content":"填写文字 利用 canvas 画板，在对应的地方绘制文字。首先我们得读取图片，把图片绘制到画板上，然后利用相关 api 进行文字绘制，具体代码贴下方。 注意：关于 * 2 是为了处理文字内容模糊的问题，具体解释请参照后面。 // canvas 读取合成图片 base64 const image = bufferToBase64(compositeImage) // 填写文字 // 注意 * 2 的目的是为了处理文字模糊的问题，node 端没有 devicePixelRatio 属性 const { width: imageWidth, height: imageHeight } = image const canvas = createCanvas(imageWidth * 2, imageHeight * 2) const ctx = canvas.getContext('2d') ctx.drawImage(image, 0, 0, imageWidth * 2, imageHeight * 2) // 开始绘制文字 drawText(ctx, content, config, imageWidth) // 创建 图片流并输出到浏览器 canvas.createPNGStream().pipe(res) 这里有两个方法 bufferToBase64 : 主要是用来将第一步合成的图片 buffer 数据转化成 canvas 可读取的 base64 图片 drawText: 对绘制文字内容的操作封装 ","date":"2020-08-20","objectID":"/posts/node-%E6%B5%B7%E6%8A%A5%E5%8A%9F%E8%83%BD%E5%AE%9E%E8%B7%B5/:4:0","tags":["node"],"title":"Node 海报功能实践","uri":"/posts/node-%E6%B5%B7%E6%8A%A5%E5%8A%9F%E8%83%BD%E5%AE%9E%E8%B7%B5/"},{"categories":["Node"],"content":"读取图片 // 将图片buffer 转化成 base64，以便 canvas 读取 function bufferToBase64(compositeImage) { const image = new Image() const data_uri_prefix = 'data:image/png;base64,' const buffer = Buffer.from(compositeImage, 'binary') image.src = data_uri_prefix + buffer.toString('base64') return image } ","date":"2020-08-20","objectID":"/posts/node-%E6%B5%B7%E6%8A%A5%E5%8A%9F%E8%83%BD%E5%AE%9E%E8%B7%B5/:4:1","tags":["node"],"title":"Node 海报功能实践","uri":"/posts/node-%E6%B5%B7%E6%8A%A5%E5%8A%9F%E8%83%BD%E5%AE%9E%E8%B7%B5/"},{"categories":["Node"],"content":"绘制文字 这里的文字内容主要分两种： 标题式：主要是单行文本，居中显出。由于设计稿给的标注不太准确，或者容易出现不合理的小数点，这里采用 canvas 的文字居中实现 内容式：内容较多，从而产生换行，左对齐。考虑到自动换行需要进行大量的文字计算，这里采用了第三方的库进行处理，具体使用方式请挪步 canvas-multiline-text。 // 绘制文字 function drawText(ctx, content, config, imageWidth) { ctx.textBaseline = 'top' Object.keys(content).forEach((key) =\u003e { const { x, y, offset, fontFamily, color, fontSize, fontStyle, fontWeight } = config[key] // 设置文字颜色 ctx.fillStyle = color // 内容多行文本处理 if (key === 'content') { const { width, height } = config[key].size // 设置文字对其方式 ctx.textAlign = 'left' drawMultilineText(ctx, content[key], { rect: { x: x * 2, y: y * 2, width: width * 2, height: height * 2 }, font: config[key].fontFamily, lineHeight: 1.5, verbose: true, minFontSize: 11 * 2, maxFontSize: 11 * 2, }) } else { // 标题类单行文本处理 // 设置文字字体大小 ctx.font = `${fontSize * 2}px \"${fontFamily}\" ${fontStyle} ${fontWeight}` ctx.textAlign = 'center' ctx.fillText(content[key], (offset || 0) + imageWidth, y * 2) } }) } ","date":"2020-08-20","objectID":"/posts/node-%E6%B5%B7%E6%8A%A5%E5%8A%9F%E8%83%BD%E5%AE%9E%E8%B7%B5/:4:2","tags":["node"],"title":"Node 海报功能实践","uri":"/posts/node-%E6%B5%B7%E6%8A%A5%E5%8A%9F%E8%83%BD%E5%AE%9E%E8%B7%B5/"},{"categories":["Node"],"content":"字体注册 当我们绘制特殊字体的时候，需要先进行注册字体，主要用 canvas 的 registerFont api。 const { createCanvas, registerFont, Image } = require('canvas') const fontPath = path.resolve(__dirname, '../public') registerFont(fontPath + '/SourceHanSansCN-Normal.otf', { family: 'SourceHanSansCN' }) registerFont(fontPath + '/SourceHanSansHWSC-Bold.otf', { family: 'SourceHanSansHWSC' }) ","date":"2020-08-20","objectID":"/posts/node-%E6%B5%B7%E6%8A%A5%E5%8A%9F%E8%83%BD%E5%AE%9E%E8%B7%B5/:4:3","tags":["node"],"title":"Node 海报功能实践","uri":"/posts/node-%E6%B5%B7%E6%8A%A5%E5%8A%9F%E8%83%BD%E5%AE%9E%E8%B7%B5/"},{"categories":["Node"],"content":"关于文字居中 关于 node-canvas 文本对齐方式，实现是跟 html canvas 一样的，请参考 MDN Canvas 。需要注意的是，设置 textAlign 后，绘制文字 fillText 的 x 坐标意义就发生了变化，而不是正常的文字最左边所在的坐标。 x 坐标 就是 对齐方式的基准线，比如居中对齐的话，文字居中的中线所在位置就是 x。可以理解为 绘制文字的区域是个矩形，这个矩形中线的位置由 x 控制。 所以当碰到海报是横着的，并且左边有部分区域以没有文字，而文字在右边区域居中的时候，需要设置一个 offest 偏移量进行处理，这也成我的配置中设置了 offset 的缘由，具体如下图所示。 海报演示 正常的居中，offset 偏移量为 0，则 x 坐标为图片的宽定 width/2。而存在 offset 的时候则是 (width - offset)/2 + offset = (offset + width)/2。所以最终居中的 x 坐标可以统一写成 (offset || 0 + width)/2。 ","date":"2020-08-20","objectID":"/posts/node-%E6%B5%B7%E6%8A%A5%E5%8A%9F%E8%83%BD%E5%AE%9E%E8%B7%B5/:4:4","tags":["node"],"title":"Node 海报功能实践","uri":"/posts/node-%E6%B5%B7%E6%8A%A5%E5%8A%9F%E8%83%BD%E5%AE%9E%E8%B7%B5/"},{"categories":["Node"],"content":"解决字体模糊问题 合成海报后发现字体模糊，主要原因还是 canvas 渲染的问题。高清屏幕一般是 2 个像素合成 1 像素。因此我们需要将 canvas 画板放大后绘制，然后缩小输出，这样就会变的清晰，主要有以下两种方式。 直接使用 scale 方法 每一个绘制相应的放大，比如我们绘制文字 第一种方法 const canvas = createCanvas(imageWidth * 2, imageHeight * 2) const ctx = canvas.getContext('2d') ctx.scale(2, 2) ctx.drawImage(image, 0, 0, imageWidth, imageHeight) ctx.font = `${fontSize}px \"${fontFamily}\" ${fontStyle} ${fontWeight}` ctx.textAlign = 'center' ctx.fillText(content[key], ((offset || 0) + imageWidth) / 2, y) 这一种方法是最简单省事的，不用转化设置好的坐标参数。但是会有一个问题，字体间距会被放大后并没有缩放回来，最后的字间距会比正常的大两倍。 我最初的想法是通过设置字间距为原本的 1/2，来解决问题，不过，node-canvas 设置字间距的 api 尚未实现，但是已经有开发者提了 pr 实现，尚未被正式支持，故采取了第二种麻烦的方法。 第二种方法** const canvas = createCanvas(imageWidth * 2, imageHeight * 2) const ctx = canvas.getContext('2d') ctx.drawImage(image, 0, 0, imageWidth * 2, imageHeight * 2) ctx.font = `${fontSize * 2}px \"${fontFamily}\" ${fontStyle} ${fontWeight}` // 设置文字对其方式 ctx.textAlign = 'center' ctx.fillText(content[key], (offset || 0) + imageWidth, y * 2) 这种方法需要手动将所有的大小以及坐标对应的进行转化，繁琐一点，但是避免了字间距过大的问题。 以上参考文章 解决 canvas 在高清屏中绘制模糊的问题 ","date":"2020-08-20","objectID":"/posts/node-%E6%B5%B7%E6%8A%A5%E5%8A%9F%E8%83%BD%E5%AE%9E%E8%B7%B5/:4:5","tags":["node"],"title":"Node 海报功能实践","uri":"/posts/node-%E6%B5%B7%E6%8A%A5%E5%8A%9F%E8%83%BD%E5%AE%9E%E8%B7%B5/"},{"categories":["数据库"],"content":"安装 mongodb 数据库 ","date":"2019-01-09","objectID":"/posts/%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%9C%AC%E5%9C%B0mongdb%E6%95%B0%E6%8D%AE%E5%BA%93/:1:0","tags":["mongdb","数据库"],"title":"建一个本地mongdb数据库","uri":"/posts/%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%9C%AC%E5%9C%B0mongdb%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["数据库"],"content":"安装包安装 进入官网，点击左上角 Get MongoDB 下载，进入中间的 server 界面，会自动匹配出对应的系统，下载对应的安装包，安装即可。 如果想看更详细的安装步骤，下载旁的侧边栏有 Install Instructions。 ","date":"2019-01-09","objectID":"/posts/%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%9C%AC%E5%9C%B0mongdb%E6%95%B0%E6%8D%AE%E5%BA%93/:1:1","tags":["mongdb","数据库"],"title":"建一个本地mongdb数据库","uri":"/posts/%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%9C%AC%E5%9C%B0mongdb%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["数据库"],"content":"命令行安装 由于我是 deepin 系统，是基于 debian 的，而且个人更喜欢用命令行进行安装,于是找到了debian 的安装指导 导入 mongodb 公共 GPG 密钥 sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 9DA31620334BD75D9DCB49F368818C72E52529D4` 创建列表文件 deepin 是基于最新的 debian，所以我这个是 Debian 9 的 echo \"deb http://repo.mongodb.org/apt/debian stretch/mongodb-org/4.0 main\" | sudo tee /etc/apt/sources.list.d/mongodb-org-4.0.list` 更新一下本地安装包数据 sudo apt-get update` 注意：此步不可省略，不然会导致报错，找不到 mongodb 包！ 安装 mongoDB 包 sudo apt-get install -y mongodb-org` 至此，mongodb 数据库算是安装成功了。官方文档还介绍了使用.tgztr 包安装的方式，感兴趣的可以去官网看看。 ","date":"2019-01-09","objectID":"/posts/%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%9C%AC%E5%9C%B0mongdb%E6%95%B0%E6%8D%AE%E5%BA%93/:1:2","tags":["mongdb","数据库"],"title":"建一个本地mongdb数据库","uri":"/posts/%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%9C%AC%E5%9C%B0mongdb%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["数据库"],"content":"运行 mongodb 数据库 启动 mongodb sudo service mongod start 检验 mongodb 是否启动成功 sudo cat /var/log/mongodb/mongod.log 这个文件纪录着 mongodb 的启动历史，所以当我们在最后一行看到一下内容，便是启动成功了 [initandlisten] waiting for connections on port 27017 运行 mongodb mongo 其实这个也可以作为 mongodb 是否启动成功的条件 停止 mongodb 运行 sudo service mongod stop 重启 mongodb sudo service mongod restart ","date":"2019-01-09","objectID":"/posts/%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%9C%AC%E5%9C%B0mongdb%E6%95%B0%E6%8D%AE%E5%BA%93/:2:0","tags":["mongdb","数据库"],"title":"建一个本地mongdb数据库","uri":"/posts/%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%9C%AC%E5%9C%B0mongdb%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["数据库"],"content":"robo 3T -mongodb 可视化工具 虽然个人喜欢用命令行进行安装，因为这样方便简单，但是用命令行查看数据库就比较不方便了毕竟，查询条件多且复杂的话，命令行界面就不够友好了，这里介绍使用 robo 3T，一个 mongdb 数据库可视化 GUI 工具。 ","date":"2019-01-09","objectID":"/posts/%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%9C%AC%E5%9C%B0mongdb%E6%95%B0%E6%8D%AE%E5%BA%93/:3:0","tags":["mongdb","数据库"],"title":"建一个本地mongdb数据库","uri":"/posts/%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%9C%AC%E5%9C%B0mongdb%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["数据库"],"content":"安装 首先在robo 3T 官网下载相应安装包,然后使用 tar 命令进行解压： tar -xzf robo3t-1.2.1-linux-x86_64-3e50a65.tar.gz` 创建一个命令将所有文件全部拷贝过去 sudo mkdir /usr/local/bin/robomongo sudo mv robo3t-1.2.1-linux-x86_64-3e50a65.tar.gz /usr/local/bin/robomongo 进入文件 robomongo 文件目录，给 robo 3T 添加权限 cd /usr/local/bin/robomongo/bin sudo chmod +x robo3t 给 robo 3T 创建快捷启动命令 sudo vi ~/.bashrc // 用 vim 编辑.bashrc 文件 alias robomongo=\"/usr/local/bin/robomongo/bin/robo3t\" // 在最后一行添加该命令,保存退出 source ~/.bashrc // 使命令生效 ","date":"2019-01-09","objectID":"/posts/%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%9C%AC%E5%9C%B0mongdb%E6%95%B0%E6%8D%AE%E5%BA%93/:3:1","tags":["mongdb","数据库"],"title":"建一个本地mongdb数据库","uri":"/posts/%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%9C%AC%E5%9C%B0mongdb%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["数据库"],"content":"连接 mongdb 数据库 首先按文章前面说的运行数据库，本地数据库运行： sudo service mongod start mongo 启动 robo 3T 进行连接 robomongo 3、输入 i 地址与端口连接指定数据库 可以连接远程数据库 ","date":"2019-01-09","objectID":"/posts/%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%9C%AC%E5%9C%B0mongdb%E6%95%B0%E6%8D%AE%E5%BA%93/:3:2","tags":["mongdb","数据库"],"title":"建一个本地mongdb数据库","uri":"/posts/%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%9C%AC%E5%9C%B0mongdb%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["博客"],"content":"最近觉得 window 下的命令行实在难看，即使是 gitbash 也无法拯救，毕竟一些乱码着实是要逼死我这种强迫症。于是下定决心，将笔记本里的另一个 linux 系统 deepin 作为主力系统，开始各方面的迁移。代码啥的都好说，毕竟有 github 托管，但是 hexo 博客就让人头疼了，对于我这个刚入行不久的小白，实在是不知道从何处下手。 ","date":"2019-01-02","objectID":"/posts/hexo-%E5%8D%9A%E5%AE%A2%E8%BD%AC%E7%A7%BB/:0:0","tags":["hexo","博客"],"title":"hexo 博客转移","uri":"/posts/hexo-%E5%8D%9A%E5%AE%A2%E8%BD%AC%E7%A7%BB/"},{"categories":["博客"],"content":"最蠢的办法 估计这个办法是只有我这种蠢人与懒人才能想出来吧，直接把 windows 下的 hexo 博客相关文件复制一份放到 deepin 下跑起来。跑之前，我猜测可能环境配置肯定会出问题，出人意料之外的，竟然成功跑起来了，没有出问题。毕竟从 windows 到 linux，个人觉得主要还是环境配置问题吧,比如 node 版本，一些环境依赖，比如 python 版本号 ","date":"2019-01-02","objectID":"/posts/hexo-%E5%8D%9A%E5%AE%A2%E8%BD%AC%E7%A7%BB/:1:0","tags":["hexo","博客"],"title":"hexo 博客转移","uri":"/posts/hexo-%E5%8D%9A%E5%AE%A2%E8%BD%AC%E7%A7%BB/"},{"categories":["博客"],"content":"通过 github 保存配置文件 基本思路：将本地所有相关配置文件上传到 github，然后 clone 到另一台电脑或者另一个系统，相关的配置文件都有了，理论上来说就是 ok 的。这样唯一的好处，就是基本可以在所有电脑里写博客后直接发布了。 ","date":"2019-01-02","objectID":"/posts/hexo-%E5%8D%9A%E5%AE%A2%E8%BD%AC%E7%A7%BB/:2:0","tags":["hexo","博客"],"title":"hexo 博客转移","uri":"/posts/hexo-%E5%8D%9A%E5%AE%A2%E8%BD%AC%E7%A7%BB/"},{"categories":["博客"],"content":"1、上传相关配置文件到 github 主要是配置文件，由于我怕出问题，基本把所有的相关配置文件都上传了，我的目录如下： hexo |--scaffolds |--source |--themes |--.gitignore |--_config.yml |--package-lock.json |--package.json ","date":"2019-01-02","objectID":"/posts/hexo-%E5%8D%9A%E5%AE%A2%E8%BD%AC%E7%A7%BB/:2:1","tags":["hexo","博客"],"title":"hexo 博客转移","uri":"/posts/hexo-%E5%8D%9A%E5%AE%A2%E8%BD%AC%E7%A7%BB/"},{"categories":["博客"],"content":"2、在另一台电脑（系统）初始化一个 hexo 博客目录 因为各个电脑系统环境配置都不一样，所以首先得保证最基本的 hexo 博客能运行起来： 首先，安装node，git npm install -g hexo-cli // 安装hexo命令工具 hexo init \u003cfolder\u003e // 初始化hexo博客目录 cd \u003cfolder\u003e npm install // 安装包依赖 ","date":"2019-01-02","objectID":"/posts/hexo-%E5%8D%9A%E5%AE%A2%E8%BD%AC%E7%A7%BB/:2:2","tags":["hexo","博客"],"title":"hexo 博客转移","uri":"/posts/hexo-%E5%8D%9A%E5%AE%A2%E8%BD%AC%E7%A7%BB/"},{"categories":["博客"],"content":"3、从 github 上git clone出 hexo 配置文件 注意 clone 的文件夹不要放在第二步创建的文件下，将 clone 的文件下的所有文件复制粘贴到第二步的初始化目录中，同名的文件选择覆盖掉。 然后，执行相关命令，如无意外即可跑起来了。 // 以下是个人的博客操作,全部在第二步的博客目录下操作 cd themes/next/ npm i // 安装next主题包依赖 cd ../../ npm i // 执行全局配置包依赖 hexo s // 本地测试hexo博客 这样配置成功后，以后只需要把写的博客、相关的主题设置文件上传到 github，其它的电脑直接从 github 上 pull 就 ok 了。 注意: 千万不要将相关的环境配置文件提交，比如 package.json，保持所有的电脑配置文件一致，不同的电脑本地进行配置，不然会导致不同的电脑环境相互冲突，需要重新配置环境。 ","date":"2019-01-02","objectID":"/posts/hexo-%E5%8D%9A%E5%AE%A2%E8%BD%AC%E7%A7%BB/:2:3","tags":["hexo","博客"],"title":"hexo 博客转移","uri":"/posts/hexo-%E5%8D%9A%E5%AE%A2%E8%BD%AC%E7%A7%BB/"},{"categories":["博客"],"content":"遇到的问题 ","date":"2019-01-02","objectID":"/posts/hexo-%E5%8D%9A%E5%AE%A2%E8%BD%AC%E7%A7%BB/:3:0","tags":["hexo","博客"],"title":"hexo 博客转移","uri":"/posts/hexo-%E5%8D%9A%E5%AE%A2%E8%BD%AC%E7%A7%BB/"},{"categories":["博客"],"content":"nodejieba 模块安装出错（windows） 不同系统之间免不了出问题，最近在公司趁闲点写点博客，于是打算在公司的电脑按上述方法进行部署。结果报错，卡在 nodejieba 分词库安装失败，node-gyp rebuild 失败。 自然第一想法，谷歌搜索报错，找到nodejieba 分词库安装问题相关答案，顺着找到node-gyp 官方文档,原来是 node-gyp 的 python 版本只支持 2.7，官方给出了前置安装的两个办法，人懒的我自然选择前一种方法 npm install --global --production windows-build-tools npm install -g node-gyp 安装完后，删掉 node_modules,重新安装依赖，万事大吉，成功运行！至此，我这篇博客就是写到一般上传到 github 后，回家拉取继续写，顺利完成。 ","date":"2019-01-02","objectID":"/posts/hexo-%E5%8D%9A%E5%AE%A2%E8%BD%AC%E7%A7%BB/:3:1","tags":["hexo","博客"],"title":"hexo 博客转移","uri":"/posts/hexo-%E5%8D%9A%E5%AE%A2%E8%BD%AC%E7%A7%BB/"},{"categories":["博客"],"content":"themes 文件 git 嵌套 由于 nextz 主题内的_config.yml 也涉及到一些配置，为避免重新配置，最好把 themes 下的主题文件也上传到 github。但是，由于 themes 下主题内部也存在 git 仓库，造成了 git 嵌套，自动被 git 忽略，所以要先着手解决 git 嵌套问题。 研究了一会，目前一种简单的办法，把 themes 内部的.git本地仓库删掉，这里要注意将 next 文件夹移出 blog，然后移入，才能重新被 git 发现。这样我们就实现了 themes 主题配置的保存。 ","date":"2019-01-02","objectID":"/posts/hexo-%E5%8D%9A%E5%AE%A2%E8%BD%AC%E7%A7%BB/:3:2","tags":["hexo","博客"],"title":"hexo 博客转移","uri":"/posts/hexo-%E5%8D%9A%E5%AE%A2%E8%BD%AC%E7%A7%BB/"},{"categories":["博客"],"content":"执行 hexo 命令报错（deepin） 执行hexo s命令报错：Error: ENOSPC: no space left on device, 大概是指监听太多 node_modules 嵌套了：max_user_watches，谷歌搜到相关答案,最终的解决办法：增大最大监听数量 由于我是 deepin 系统，命令行执行： echo fs.inotify.max_user_watches=524288 | sudo tee -a /etc/sysctl.conf \u0026\u0026 sudo sysctl -p ","date":"2019-01-02","objectID":"/posts/hexo-%E5%8D%9A%E5%AE%A2%E8%BD%AC%E7%A7%BB/:3:3","tags":["hexo","博客"],"title":"hexo 博客转移","uri":"/posts/hexo-%E5%8D%9A%E5%AE%A2%E8%BD%AC%E7%A7%BB/"},{"categories":["博客"],"content":"npm install 安装环境报错（deepin） 报错： pngquant-bin@4.0.0 postinstall: node lib/install.js Failed at the pngquant-bin@4.0.0 postinstall script. 报错大概是指 pngquant-bin 这个模块运行出错。谷歌搜索答案，得知 pngquant-bin 在 Linux 下需要一些包 libpng-dev，但是仅仅安装这个包是不够的。 具体参考： npm.js 包 pngquant-bin node_modules/pngquant-bin/vendor/pngquant` binary doesn’t seem to work correctly pngquant failed to build, make sure that libpng-dev is installed 解决方案： 运行以下命令 sudo apt-get install libpng-dev sudo npm install -g pngquant-bin 一般而言以上命令就可以解决了，但是有时候 pngquant-bin 安装报错，就尝试一下命令： sudo apt-get install -y build-essential libpng-dev 如过还失败，再尝试： sudo apt-get update sudo apt-get install libtiff5-dev libtiff5 libjbig-dev ","date":"2019-01-02","objectID":"/posts/hexo-%E5%8D%9A%E5%AE%A2%E8%BD%AC%E7%A7%BB/:3:4","tags":["hexo","博客"],"title":"hexo 博客转移","uri":"/posts/hexo-%E5%8D%9A%E5%AE%A2%E8%BD%AC%E7%A7%BB/"},{"categories":["工具"],"content":"命令行使用 vs code 命令查找：Ctrl + Shift + P/Cmd + Shift + P code + \u003cfilename\u003e/\u003cfilepath\u003e 打开文件或者文件目录 参数 作用 注意项 -r 在同一窗口打开 会删掉原有工作区，只保留一个 -g \u003c file:line[character] \u003e 打开文件，自动跳转到文件中某个特定的行与列 无 -d \u003c path1 \u003e \u003c path2 \u003e 用来比较两个文件的内容，传入两个文件路径 无 code -r -g package.json:128 // 表示打开package.json文件，自动跳转到128 code -r -d a.txt b.txt // 比较a.txt 与b.txt 文件的内容 ls | code // 把当前目录下的所有文件名都展示在编辑器里 ","date":"2018-12-18","objectID":"/posts/vscode-%E5%BF%AB%E6%8D%B7%E6%93%8D%E4%BD%9C/:1:0","tags":["vscode","工具"],"title":"vscode 快捷操作","uri":"/posts/vscode-%E5%BF%AB%E6%8D%B7%E6%93%8D%E4%BD%9C/"},{"categories":["工具"],"content":"双手不离键盘 ","date":"2018-12-18","objectID":"/posts/vscode-%E5%BF%AB%E6%8D%B7%E6%93%8D%E4%BD%9C/:2:0","tags":["vscode","工具"],"title":"vscode 快捷操作","uri":"/posts/vscode-%E5%BF%AB%E6%8D%B7%E6%93%8D%E4%BD%9C/"},{"categories":["工具"],"content":"光标的移动 windows mac/linux 作用 Ctrl + 左右方向键 Opiton + 左右方向键 移动一个单词的距离 home/end cmd + 左右方向键 移动到行首或行尾 Ctrl + M Cmd + shift + \\ 代码块的光标移动（光标在中括号上的跳转） Ctrl + Home/End Cmd + Home/End 移动到文档的第一行、最后一行 ","date":"2018-12-18","objectID":"/posts/vscode-%E5%BF%AB%E6%8D%B7%E6%93%8D%E4%BD%9C/:2:1","tags":["vscode","工具"],"title":"vscode 快捷操作","uri":"/posts/vscode-%E5%BF%AB%E6%8D%B7%E6%93%8D%E4%BD%9C/"},{"categories":["工具"],"content":"文本选择 基于光标移动的操作基础上 多一个 shift 键就可以在移动的同时选择文本 注意： ctrle + 上下方向键 上下移动移动整行 ","date":"2018-12-18","objectID":"/posts/vscode-%E5%BF%AB%E6%8D%B7%E6%93%8D%E4%BD%9C/:2:2","tags":["vscode","工具"],"title":"vscode 快捷操作","uri":"/posts/vscode-%E5%BF%AB%E6%8D%B7%E6%93%8D%E4%BD%9C/"},{"categories":["工具"],"content":"删除操作 常用操作：选中文本，然后删除！ windows mac/linux 作用 fn + delete 删除该行右侧所有内容 Cmd + Delete 删除该行左侧所有内容 Ctrl + Delete fn + Delete 删除字符右侧的内容 Ctrl + 删除键 fn + 删除键 删除字符左侧的内容 ","date":"2018-12-18","objectID":"/posts/vscode-%E5%BF%AB%E6%8D%B7%E6%93%8D%E4%BD%9C/:2:3","tags":["vscode","工具"],"title":"vscode 快捷操作","uri":"/posts/vscode-%E5%BF%AB%E6%8D%B7%E6%93%8D%E4%BD%9C/"},{"categories":["工具"],"content":"自定义快捷键 查找 vscode 默认快捷键方式： Ctrl + Shift + P查找键盘快捷方式 ","date":"2018-12-18","objectID":"/posts/vscode-%E5%BF%AB%E6%8D%B7%E6%93%8D%E4%BD%9C/:3:0","tags":["vscode","工具"],"title":"vscode 快捷操作","uri":"/posts/vscode-%E5%BF%AB%E6%8D%B7%E6%93%8D%E4%BD%9C/"},{"categories":["总结"],"content":"入职新公司大概有一周左右了，也逐渐适应了新公司的工作与周围的环境。在工作之余也该好好计划下自己的学习与技术增长了。给自己定个半年的目标，主要分在两个方面： 工作 —- 经验增长，团队合作交流，前后端工作交流 生活 —- 学习能力的增长。 ","date":"2018-11-25","objectID":"/posts/futrue-plan/:0:0","tags":["总结"],"title":"半年计划","uri":"/posts/futrue-plan/"},{"categories":["总结"],"content":"工作 公司目前主要技术栈以 vue + element UI 为主，后端是 Java ，前端由于之前旧的项目前后端未分离，涉及到 express 框架。公司目前的几个项目： PC 端 pos ，之前的老项目，技术栈混乱，前后端未分离，涉及到 express、vue、jquery 等复杂且落后的技术。 目前 pos 端计划用 vue + element UI 重构 pos 端，主要以现成的 vue-element-admin UI 框架为主，实现重构。 移动端微商城，已经开发完成，主要运用有赞前端团队出的 UI 框架与 vue 技术，后期主要以维护为主，可以多看源码，了解学习其中的业务需求实现，做到能解决所有 bug 及新增的需求完成。 App 端，导购 App，之前的项目问题太多，直接推翻重做，由前端开发，主要利用基于 vue 开发三端的 weex 技术，实现 Android 与 ios app 的开发。 目前我主要负责的是公司的新项目开发，基于此种现状，目前主要精力应放在以下几点： 增加 vue 熟练度，对 vue 在开发工作的每一个流程熟稔于心，深入了解实现 vue-router、vuex 等在实际工作的运用，甚至搞熟 vue 服务器端的渲染以及 ssr 等必知概念。 基于 vue ，开始了解 Android 开发及 ios 开发，完成基本工作的同时，能独立实现一个网易云音乐 App，或者一个笔记便签类的 App。 深入学习理解 vue-element-admin，这个中后台 UI 框架的实现原理，并详细学习记录其基本业务需求，以及实际工作中的业务完善，争取利用其原理与基本模板，实现一个博客管理系统，或者一个组件展示页面（类似与 Vuepress） 由于公司之前的项目前后端未分离，技术栈混乱，因此是一个学习写文档，建立代码规范，学习团队合作的好机会，要做好每次学习的记录。 ","date":"2018-11-25","objectID":"/posts/futrue-plan/:1:0","tags":["总结"],"title":"半年计划","uri":"/posts/futrue-plan/"},{"categories":["总结"],"content":"个人学习 基于公司的工作情况，个人未来技术的期望，做出如下分析： 基础：由于非计算机专业，在一些计算机原理及系统方面的知识很薄弱，未来一定要计划加强，但半年内不考虑，第七个月开始计划执行学习。 算法：虽说前端算法要求不高，但是作为个人职业发展，算法很重要。故前期学习巩固基本的算法。 JS：无论前端的框架如何发展变化，前端的核心依然是 JavaScript ，故依然要在 JS 上花时间精力深入学习。 Html5\u0026\u0026Css3：前端的核心写页面，故做一个好看的页面至关重要，上周在公司做的系统维护升级页面与 404 页面，对 css 还不够熟练花的时间有点久，应该多拿些精美页面练习。 网络协议：前端很重要的一部分，网络协议，也是个人薄弱之处，深入学习巩固 Http 协议的全部知识。 JS 框架：对 vue 的运用不够熟练，vue 的进阶使用还不够深入了解，要在这方面深入学习。小程序与 React 要深入学习掌握。 Node：目前以了解为主，半年后深入学习掌握，然后借此机会开始学习 TCP/IP 协议。 由于多方面的原因，业余学习时间可能不充足，做出如下计划安排： JS：日常学习巩固 JS 基础知识：以红皮书、阮一峰 JS 标准、ES6 为主，巩固学习基本知识。以你不知道的 JavaScript 系列为主，深入学习理解 JS 的基本概念。这些计划在三个月内实现。 网络协议：由于书本不在身边，过年前以“极客时间”上的网络专栏为主学习，不够网上找慕课网 HTTP 协议视屏观看，注意写——博客——总结！！！（即使费时间，速度慢也要写。） 算法：以极客时间专栏为主：写主要算法的实现原理及 JS 实现总结博客。 Vue：完成慕课网 vue 去哪儿网实战视屏，借用其资源，争取自己手写整个项目。同时看完 Vue.js 实战书籍，并完成其中的项目，同时将 iView 的一些组件充入自己的 UI 框架项目中。 Html5\u0026\u0026Css3：这块主要以练习为主，看为辅，学习一门 css 预处理语言，就scss了，练习在codepen上或者dribble上找页面实现，同时复习 css 深入浅出课程，平均一个月完成一个大型网站的 demo，与此同时将之前在掘金上收藏的有关 css 特效的文章一一实现，并写博客总结。 框架：前期以小程序学习为主，主要看极客时间的小程序专栏，并完成掘金小册的小程序项目。待小程序熟悉后，vue 应该深入了解差不多了，此时开始深入学习 React ,主要以极客时间专栏为主，配合慕课网视屏完成一个大项目。 Node:node 目前不是主要方向，平时想要看了，拿 node 深入浅出，学习，以 CMR 的方式敲代码学习。 工具类：主要是两个，一个 vscode，主要以极客时间专栏为主。其次是 webpack，主要以掘金小册为主。目标：个人实现工作效率的提升，会定制开发环境，极大提高个人开发效率，并能指导同事完成前端环境的配置。 博客美化：试着深入了解 hexo 博客主题的原理，逐渐完善主题的配置，实现个人博客的提升。 从上面分析计划看来，个人技术水平还是有限，需要大力提升自身技术水平。由于时间精力有限，没有 Typescript 的学习计划，这半年内可能会有调整，目前先试着考虑。目前的工作来看，可能平时会比较辛苦，但坚持吧，每天坚持多学一点，慢慢积累就会多了。周末尽量多做一些大型的内容，多敲代码，提升自身写代码的能力。 ","date":"2018-11-25","objectID":"/posts/futrue-plan/:2:0","tags":["总结"],"title":"半年计划","uri":"/posts/futrue-plan/"},{"categories":["node"],"content":"什么是 Express？ 官网介绍：Express 是基于 Node.js 平台，快速、开放、极简的 Web 开发框架。 个人理解：我们都知道 node.js 是后端版本的 js 语言实现，自然 Express 更加注重的是后端的处理，它的页面是通过数据与模版渲染而成，注重的是逻辑的交互。与其它常见的前端框架不同，像 Vue、React 等基本思想都是数据驱动视图，我们不必去关注后台是怎么实现的，只注重数据的操作。而 Express 恰恰相反。 ","date":"2018-10-25","objectID":"/posts/express-%E5%85%A5%E9%97%A8/:1:0","tags":["express","node"],"title":"express 入门","uri":"/posts/express-%E5%85%A5%E9%97%A8/"},{"categories":["node"],"content":"写一个 hello word ","date":"2018-10-25","objectID":"/posts/express-%E5%85%A5%E9%97%A8/:2:0","tags":["express","node"],"title":"express 入门","uri":"/posts/express-%E5%85%A5%E9%97%A8/"},{"categories":["node"],"content":"安装 安装 node.js 后，在工作目录下运行一下命令 //通过 npm init 命令为你的应用创建一个 package.json 文件。 npm init //安装Express npm install express --save ","date":"2018-10-25","objectID":"/posts/express-%E5%85%A5%E9%97%A8/:2:1","tags":["express","node"],"title":"express 入门","uri":"/posts/express-%E5%85%A5%E9%97%A8/"},{"categories":["node"],"content":"hello word 创建一个 app.js 文件，内容如下 const express = require('express') const app = express() app.get('/', (req, res) =\u003e res.send('Hello World!')) app.listen(3000, () =\u003e console.log('Example app listening on port 3000!')) 然后在在浏览器中打开 http://localhost:3000/，就可以看到网页了，就这么简单。 ","date":"2018-10-25","objectID":"/posts/express-%E5%85%A5%E9%97%A8/:2:2","tags":["express","node"],"title":"express 入门","uri":"/posts/express-%E5%85%A5%E9%97%A8/"},{"categories":["node"],"content":"Express application generator Express 提供给我们一个可以快速创建一个应用的骨架的应用生成器：express-generator。它可以帮助我们快速建立一个网站基本需要的所有文件。 ","date":"2018-10-25","objectID":"/posts/express-%E5%85%A5%E9%97%A8/:3:0","tags":["express","node"],"title":"express 入门","uri":"/posts/express-%E5%85%A5%E9%97%A8/"},{"categories":["node"],"content":"本地安装 npm install express-generator ","date":"2018-10-25","objectID":"/posts/express-%E5%85%A5%E9%97%A8/:3:1","tags":["express","node"],"title":"express 入门","uri":"/posts/express-%E5%85%A5%E9%97%A8/"},{"categories":["node"],"content":"创建应用 通过命令 express -h 可以查看可用的命令参数，其中-f强制在非空目录下创建应用，-v表示 view 的模版引擎。 npx express . -f -e //安装依赖 npm install 表示在强制（-f）在当前目录（.）下创建 view=ejs（ -e 模版引擎） 的应用。根目录下会生成下述文件： ","date":"2018-10-25","objectID":"/posts/express-%E5%85%A5%E9%97%A8/:3:2","tags":["express","node"],"title":"express 入门","uri":"/posts/express-%E5%85%A5%E9%97%A8/"},{"categories":["node"],"content":"基本运行 运行命令 DEBUG=sticky-note:* npm start //或者直接 npm start 然后在浏览器中打开 http://localhost:3000/ 网址就可以看到这个应用了。 我们在 package.json 文件中可以看到 npm start 是命令 node ./bin/www 的缩写，实际运行了 bin/www 文件，打开 www 文件我们会发现会去运行根目录下的 app.js 文件。 在 app.js 文件中，重要的如下几行代码： 设置模版引擎与路由跳转，当页面跳转至不同的路由时，运行 router 下对应的文件，获取数据与 view 下的模版结合渲染页面。看看 router 目录下的 index.js 文件，响应的同时，通过 render 函数对数据与模版的结合渲染页面。 ","date":"2018-10-25","objectID":"/posts/express-%E5%85%A5%E9%97%A8/:3:3","tags":["express","node"],"title":"express 入门","uri":"/posts/express-%E5%85%A5%E9%97%A8/"},{"categories":["node"],"content":"Express 的 MVC 我们仔细观察目录会发现，express 具有 MVC 的思想： routes 控制路由的跳转，逻辑行为操作：C view 是页面的模版，视图：V 应该还有一个获取数据的 model 这样看来，结构与思想上都具备 MVC 的思想。 ","date":"2018-10-25","objectID":"/posts/express-%E5%85%A5%E9%97%A8/:3:4","tags":["express","node"],"title":"express 入门","uri":"/posts/express-%E5%85%A5%E9%97%A8/"},{"categories":["JS"],"content":"Array 定义 数组是按次序排列的一组值，每个值都有一个下标，按顺序从零开始。 数组自带一个属性 length，表示数组的长度即有多少个值，其数值为最后一个值下标+1。 数组是一种特殊的对象，他的键名是按次序排列的一组整数，而他的键值可以是任意值。 判断数组方法： Array.isArray() ","date":"2018-09-15","objectID":"/posts/js%E4%B9%8B%E6%95%B0%E7%BB%84/:1:0","tags":["JS"],"title":"JS之数组","uri":"/posts/js%E4%B9%8B%E6%95%B0%E7%BB%84/"},{"categories":["JS"],"content":"创建一个数组 创建数组的方式有两种： 使用 Array 构造函数 根据给构造函数传递参数的不同，生成不同的数组 传递一个数值，创建一个给定数量的数组 var colors = new Array(3)创建一个包含 3 项的数组 传递其它类型的参数，创建一个包含该参数的一个数组 var names = new Array('blue')创建一个包含 blue 字符串的数组 使用数组字面量表示法 ","date":"2018-09-15","objectID":"/posts/js%E4%B9%8B%E6%95%B0%E7%BB%84/:2:0","tags":["JS"],"title":"JS之数组","uri":"/posts/js%E4%B9%8B%E6%95%B0%E7%BB%84/"},{"categories":["JS"],"content":"数组的增删查改 ","date":"2018-09-15","objectID":"/posts/js%E4%B9%8B%E6%95%B0%E7%BB%84/:3:0","tags":["JS"],"title":"JS之数组","uri":"/posts/js%E4%B9%8B%E6%95%B0%E7%BB%84/"},{"categories":["JS"],"content":"数组的增删 length 属性： 可以通过设置数组的 length 属性，从数组的末尾移除项或向数组中添加新项。 栈方法： 模仿栈数据结构的方法，后进先出。 push 与 pop 方法都改变了原数组，只是返回值不同，push 返回改变后数组的长度 length，而 pop 返回数组移除的最后一项。 push() 接受任意数量的参数，将它们逐个添加到数组的末尾，并返回修改的的数组的长度（length） pop() 从数组末尾移除最后一项，减少数组的 length 值，并返回移除的项 队列方法： 模仿队列数据结构的方法，先进先出。 shift 与 push 方法可以实现队列那样的行为 shift() 移除数组的第一项，减少数组的 length 值，并返回移除的项 unshift()同 shift 相反，与 push 类似 接受任意数量的参数，将他们逐个添加到数组的开头，并返回数修改后的数组的长度 ","date":"2018-09-15","objectID":"/posts/js%E4%B9%8B%E6%95%B0%E7%BB%84/:3:1","tags":["JS"],"title":"JS之数组","uri":"/posts/js%E4%B9%8B%E6%95%B0%E7%BB%84/"},{"categories":["JS"],"content":"数组的查改 获取数组中元素的位置：返回的是索引 接受两个参数，要查找的项和表示查找起点位置的索引，第二个参数可选，默认为 0。返回要查找的项在数组中的位置（索引），如果没找到返回-1。 查找比较每一项时，会使用全等操作符（===） indexOf()从开头向末尾查找 lastIndexOf()从末尾向开头查找 var numbers = [1, 2, 3, 4, 5, 6, 5, 4, 3, 2, 1] console.log(numbers.indexOf(4)) // 3 console.log(numbers.lastIndexOf(4)) // 7 console.log(numbers.indexOf(4, 4)) // 7 console.log(numbers.lastIndexOf(4, 4)) // 3 console.log(numbers.lastIndexOf(4, 3)) // 3 console.log(numbers.lastIndexOf(4, 2)) // -1 console.log(numbers.lastIndexOf(0)) // -1 数组的拼接： concat()方法：基于当前数组的所有项创建一个新的数组。 将传入的值，添加到该数组中，并返回一个新的数组。如果传入的是一个或多个数组，则将传入的数组中的每一项添加到该数组中。如果不是数组，则会被简单的添加到数组的末尾。 var colors = ['red', 'green', 'blue'] var colors2 = colors.concat('yellow', ['blcak', 'grey']) console.log(colors2) // [\"red\",\"green\",\"blue\",\"yellow\",\"blcak\",\"grey\"] join()方法：以指定参数作为分隔符，将所有数组成员连接为一个字符串返回。如果不提供参数，默认用逗号分隔。 var a = [1, 2, 3, 4] a.join(' ') // '1 2 3 4' a.join(' | ') // \"1 | 2 | 3 | 4\" a.join() // \"1,2,3,4\" 数组的截取： slice()方法：基于当前数组中的一个或多个项创建一个新数组。 接受 2 个参数，即要返回数的起始位置和结束位置（不包括）。可以省略第二个参数，默认返回从起始位置到末尾的数组。该方法返回的是一个新数组，并不会影响原数组。 数组的splice()方法 splice 方法接受三个参数：要删除第一项的位置，删除的项数，要插入的项（可以是多个）。 最终返回一个包含删除项的数组，如果没有（第二个参数为 0），则返回空数组。 根据三个参数的不同，可以实现三种功能： 删除：splice(0,2)删除数组的前两项 插入：splice(2,0,\"red\",\"blue\")会从当前数组位置 2 开始插入字符串 替换：splice(2,1,\"red\",\"blue\")会删除掉 2 位置的项，然后从位置 2 开始插入字符串 ","date":"2018-09-15","objectID":"/posts/js%E4%B9%8B%E6%95%B0%E7%BB%84/:3:2","tags":["JS"],"title":"JS之数组","uri":"/posts/js%E4%B9%8B%E6%95%B0%E7%BB%84/"},{"categories":["JS"],"content":"数组的迭代 每一个方法接受两个参数： 每一项运行的函数：该函数接受三个参数： 数组的每一项（item） 该项在数组中的位置（index）（可省略） 数组对象本身（Array）（可省略） 运行该函数的作用域对象：影响 this 的值。 every():对数组的每一项运行给定函数，当每一项都返回 true 时，every()返回 true。 some():对数组的每一项裕兴给定函数，当其中任一项返回 true，some()返回 true。 filter():对数组的每一项运行给定函数，数组中返回 true 的项，组成一个新数组返回。 map():对数组的每一项运行给定函数，返回对每一项函数运行的结果(返回的值)组成的新数组。 forEach():对数组的每一项运行给定函数，无返回值。 注意： 前面四中方法都是返回一个新的值，并没有改变原数组，而 forEach 操作了原数组 forEach 本质与 for in 循环类似，forEach 方法无法中断执行，总是会将所有成员遍历完。如果希望符合某种条件时，就中断遍历，要使用 for 循环。 var numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9] var everyN = numbers.every((item) =\u003e { return item \u003e 0 }) everyN // true var someN = numbers.some((item) =\u003e { return item % 2 === 0 }) someN // true var filterN = numbers.filter((item) =\u003e { return item % 2 === 0 }) // filterN //[2,4,6,8] var mapN = numbers.map((item) =\u003e { return item * 2 }) mapN // [2,4,6,8,10,12,14,16,18] var forEachN = numbers.forEach((item) =\u003e { item = item + 2 }) ","date":"2018-09-15","objectID":"/posts/js%E4%B9%8B%E6%95%B0%E7%BB%84/:4:0","tags":["JS"],"title":"JS之数组","uri":"/posts/js%E4%B9%8B%E6%95%B0%E7%BB%84/"},{"categories":["JS"],"content":"数组的归并 接受两个参数： 每一项上调用的函数 这个函数接受 4 个参数： 前一个值 当前值 项的索引 数组对象 作为归并基础的初始值 函数返回的值都会作为初始值传给下一项，即数组的第一项调用函数的返回值会作为数组第二项调用函数的初始值参数。 迭代(遍历)数组的所有项，返回最终值。 reduce(): 从第一项开始遍历数组 reduceRight()：从最后一项向第一项遍历数组 var values = [1, 2, 3, 4, 5] values.reduce((prev, cur, index, array) =\u003e { return prev + cur }) // ((((1+2)+3)+4)+5) == 15 ","date":"2018-09-15","objectID":"/posts/js%E4%B9%8B%E6%95%B0%E7%BB%84/:5:0","tags":["JS"],"title":"JS之数组","uri":"/posts/js%E4%B9%8B%E6%95%B0%E7%BB%84/"},{"categories":["JS"],"content":"数组的排序 sort() sort()方法会先调用数组每一项的 tostring()方法，然后比较得到的字符串，确定如何排序，所以实际排序的是每一项的 unicode 编码顺序。 改进：接受一个比较函数。 如果第一个参数应该位于第二个参数前则返回一个负数，如果两个参数相等则返回 0，如果第一个参数应该位于第二个参数之后则返回一个正数。 function compare(val1, val2) { if (val \u003c val2) { return -1 } else if (val1 \u003e val2) { return 1 } else { return 0 } } z //上述代码优化 function compare(val1, val2) { return val1 - val2 } //从小到大 var values = [0, 5, 8, 7, 10] values.sort(compare) values // [0,5,7,8,10] reverse() reverse()反转数组项的顺序 ","date":"2018-09-15","objectID":"/posts/js%E4%B9%8B%E6%95%B0%E7%BB%84/:6:0","tags":["JS"],"title":"JS之数组","uri":"/posts/js%E4%B9%8B%E6%95%B0%E7%BB%84/"},{"categories":["JS"],"content":"数组的去重 计数排序逻辑：（只能正整数） var a = [4, 2, 5, 6, 3, 4, 5] function removeSame(array) { var hashTab = {} for (let i = 0; i \u003c a.length; i++) { if (a[i] in hashTab) { // 什么也不做 } else { hashTab[a[i]] = true } } //hashTab: {4: true, 2: true, 5: true, 6:true, 3: true} return Object.keys(hashTab) // ['4','2','5','6','3'] } ","date":"2018-09-15","objectID":"/posts/js%E4%B9%8B%E6%95%B0%E7%BB%84/:7:0","tags":["JS"],"title":"JS之数组","uri":"/posts/js%E4%B9%8B%E6%95%B0%E7%BB%84/"},{"categories":["node"],"content":"什么是脚本 类似于话剧中的剧本，脚本是计算机的“剧本”，脚本即给计算机一行一行执行的文本。 用不同的语言写脚本，有不同的语法。bash 脚本有 bash 脚本语法，JS 脚本有其语法，只是 JS 脚本使用 JavaScript 语言写的。 ","date":"2018-09-04","objectID":"/posts/%E4%BB%80%E4%B9%88%E6%98%AF%E8%84%9A%E6%9C%AC/:1:0","tags":["node"],"title":"初识脚本","uri":"/posts/%E4%BB%80%E4%B9%88%E6%98%AF%E8%84%9A%E6%9C%AC/"},{"categories":["node"],"content":"用 bash 写脚本 ","date":"2018-09-04","objectID":"/posts/%E4%BB%80%E4%B9%88%E6%98%AF%E8%84%9A%E6%9C%AC/:2:0","tags":["node"],"title":"初识脚本","uri":"/posts/%E4%BB%80%E4%B9%88%E6%98%AF%E8%84%9A%E6%9C%AC/"},{"categories":["node"],"content":"创建脚本 新建脚本 找个地方新建目录mkdir ～/local 进入目录cd ~/local 创建脚本touch demo.txt（文件后缀无所谓的） 编辑脚本内容如下: pwd # 确认一下当前路径是不是 ~/local 或者 /c/Users/你的名字/local mkdir demo cd demo mkdir css js touch index.html css/style.css js/main.js exit 在任意位置执行sh ~/local/demo.txt即可运行此脚本。 cd ~/Desktop sh ~/local/demo.txt 在当前目录里会多出一个 demo 目录，demo 目录里会有一些文件 ","date":"2018-09-04","objectID":"/posts/%E4%BB%80%E4%B9%88%E6%98%AF%E8%84%9A%E6%9C%AC/:2:1","tags":["node"],"title":"初识脚本","uri":"/posts/%E4%BB%80%E4%B9%88%E6%98%AF%E8%84%9A%E6%9C%AC/"},{"categories":["node"],"content":"设置 PATH cd ~/local;pwd得到local的绝对路径 临时设置 PATH a. 运行export PATH=\"loacal的绝对路径：$PATH\",这句话是把 local 目录加到 PATH 里 b. 这时只需要运行demo.txt就相当于运行sh ~/local/demo.txt 永久设置 PATH，上面的 PATH 在你重启 Bash 之后就会失效，如果你希望 PATH 一直生效，看下面： a. 创建～/.bashrc:touch ~/.bashrc b. 编辑～/.bashrc:start ~/.bashrc c. 在编辑器里添加一行：export PATH=\"loacal的绝对路径：$PATH\" d. source ~/.bashrc e. 现在只需要运行 demo.txt 即可 ","date":"2018-09-04","objectID":"/posts/%E4%BB%80%E4%B9%88%E6%98%AF%E8%84%9A%E6%9C%AC/:2:2","tags":["node"],"title":"初识脚本","uri":"/posts/%E4%BB%80%E4%B9%88%E6%98%AF%E8%84%9A%E6%9C%AC/"},{"categories":["node"],"content":"升级脚本 升级脚本，让目录名可变： $1表示命令的第一个参数 -d $1判断目录是否存在 if [ -d $1 ]; then echo 'error: dir exists' exit else mkdir $1 cd $1 mkdir css js touch index.html css/style.css js/main.js echo 'success' exit fi 创建文件的同时编写内容（注意换行与转义）： echo -e \"\u003c!DOCTYPE\u003e\\n\u003ctitle\u003eHello\u003c/title\u003e\\n\u003ch1\u003eHi\u003c/h1\u003e\" \u003e index.html echo -e \"h1{color: red;}\" \u003e css/style.css echo -e \"var string = \\\"Hello World\\\"\\nalert(string)\" \u003e js/main.js 返回值 exit 0表示没有错误 exit 1表示错误代码为 1 ","date":"2018-09-04","objectID":"/posts/%E4%BB%80%E4%B9%88%E6%98%AF%E8%84%9A%E6%9C%AC/:2:3","tags":["node"],"title":"初识脚本","uri":"/posts/%E4%BB%80%E4%B9%88%E6%98%AF%E8%84%9A%E6%9C%AC/"},{"categories":["node"],"content":"用 node.js 写脚本 运行 JS 脚本使用命令node demo.js ","date":"2018-09-04","objectID":"/posts/%E4%BB%80%E4%B9%88%E6%98%AF%E8%84%9A%E6%9C%AC/:3:0","tags":["node"],"title":"初识脚本","uri":"/posts/%E4%BB%80%E4%B9%88%E6%98%AF%E8%84%9A%E6%9C%AC/"},{"categories":["node"],"content":"用 JS 切换目录 console.log(process.cwd()) 打印当前目录 // process.chdir('~/Desktop'); 这句话不行的，因为 JS 不认识 ~ 目录 process.chdir(\"/Users/frank/Desktop\") ","date":"2018-09-04","objectID":"/posts/%E4%BB%80%E4%B9%88%E6%98%AF%E8%84%9A%E6%9C%AC/:3:1","tags":["node"],"title":"初识脚本","uri":"/posts/%E4%BB%80%E4%B9%88%E6%98%AF%E8%84%9A%E6%9C%AC/"},{"categories":["node"],"content":"JS 脚本创建目录 let fs = require('fs')请求文件系统 fs.mkdirSync('demo')创建目录 ","date":"2018-09-04","objectID":"/posts/%E4%BB%80%E4%B9%88%E6%98%AF%E8%84%9A%E6%9C%AC/:3:2","tags":["node"],"title":"初识脚本","uri":"/posts/%E4%BB%80%E4%B9%88%E6%98%AF%E8%84%9A%E6%9C%AC/"},{"categories":["node"],"content":"JS 脚本创建文件 let fs = require('fs') fs.writeFileSync(\"./index.html\", \"\")创建内容为空的文件 ","date":"2018-09-04","objectID":"/posts/%E4%BB%80%E4%B9%88%E6%98%AF%E8%84%9A%E6%9C%AC/:3:3","tags":["node"],"title":"初识脚本","uri":"/posts/%E4%BB%80%E4%B9%88%E6%98%AF%E8%84%9A%E6%9C%AC/"},{"categories":["node"],"content":"用 JS 脚本重写 demo.sh 创建~/local/jsdemo.js 脚本 #!/usr/bin/env node var fs = require('fs') var dirName = process.argv[2] //你传的参数是从第二个开始 if (fs.existsSync('./' + dirName)) { console.log('文件已经存在') } else { fs.mkdirSync('./' + dirName) process.chdir('./' + dirName) fs.mkdirSync('css') fs.mkdirSync('js') fs.writeFileSync('./index.html', '\u003c!DOCTYPE\u003e\\n\u003ctitle\u003eHello\u003c/title\u003e\\n\u003ch1\u003eHi\u003c/h1\u003e') fs.writeFileSync('css/style.css', 'h1{color: red;}') fs.writeFileSync('js/main.js', 'var string = \"Hello World\"\\nalert(string)') } process.exit(0) 进入桌面，运行node ～/localjsdemo.js zzz可以看到 zzz 目录创建成功 ","date":"2018-09-04","objectID":"/posts/%E4%BB%80%E4%B9%88%E6%98%AF%E8%84%9A%E6%9C%AC/:3:4","tags":["node"],"title":"初识脚本","uri":"/posts/%E4%BB%80%E4%B9%88%E6%98%AF%E8%84%9A%E6%9C%AC/"},{"categories":["node"],"content":"什么是 PATH PATH 的作用：在 Bash 中输入的命令（类似 ls，cd 等），实际上是一个都是一个脚本文件，Bash 都会去 PATH 中寻找对应的文件，找到则运行该文件脚本。 使用type demo 可以看到该命令的寻找过程 使用which demo 可以看到该命令的寻找结果 ","date":"2018-09-04","objectID":"/posts/%E4%BB%80%E4%B9%88%E6%98%AF%E8%84%9A%E6%9C%AC/:4:0","tags":["node"],"title":"初识脚本","uri":"/posts/%E4%BB%80%E4%B9%88%E6%98%AF%E8%84%9A%E6%9C%AC/"},{"categories":["node"],"content":"什么是 shebang 可以在脚本中配置执行环境，如在 node.js 脚本中第一行添加： #!/usr/bin/env node 则脚本自动运行在 ndoe 环境中 ","date":"2018-09-04","objectID":"/posts/%E4%BB%80%E4%B9%88%E6%98%AF%E8%84%9A%E6%9C%AC/:5:0","tags":["node"],"title":"初识脚本","uri":"/posts/%E4%BB%80%E4%B9%88%E6%98%AF%E8%84%9A%E6%9C%AC/"},{"categories":["node"],"content":"shell 命令中；、\u0026\u0026与||的使用 ","date":"2018-09-04","objectID":"/posts/%E4%BB%80%E4%B9%88%E6%98%AF%E8%84%9A%E6%9C%AC/:6:0","tags":["node"],"title":"初识脚本","uri":"/posts/%E4%BB%80%E4%B9%88%E6%98%AF%E8%84%9A%E6%9C%AC/"},{"categories":["node"],"content":"“;“运算符 按先后顺序，一次执行多个命令 语法格式： command1；command2；command3 ","date":"2018-09-04","objectID":"/posts/%E4%BB%80%E4%B9%88%E6%98%AF%E8%84%9A%E6%9C%AC/:6:1","tags":["node"],"title":"初识脚本","uri":"/posts/%E4%BB%80%E4%B9%88%E6%98%AF%E8%84%9A%E6%9C%AC/"},{"categories":["node"],"content":"“\u0026\u0026“运算符 \u0026\u0026左边的命令（命令 1）返回真(即返回 0，成功被执行）后，\u0026\u0026右边的命令（命令 2）才能够被执行； 换句话说，“如果这个命令执行成功\u0026\u0026那么执行这个命令”。 语法格式如下： command1 \u0026\u0026 command2 [\u0026\u0026 command3 ...] ","date":"2018-09-04","objectID":"/posts/%E4%BB%80%E4%B9%88%E6%98%AF%E8%84%9A%E6%9C%AC/:6:2","tags":["node"],"title":"初识脚本","uri":"/posts/%E4%BB%80%E4%B9%88%E6%98%AF%E8%84%9A%E6%9C%AC/"},{"categories":["node"],"content":"“||“运算符 ||则与\u0026\u0026相反。如果||左边的命令（命令 1）未执行成功，那么就执行||右边的命令（命令 2）； 换句话说，“如果这个命令执行失败了||那么就执行这个命令。 语法格式如下： command1 || command2 ","date":"2018-09-04","objectID":"/posts/%E4%BB%80%E4%B9%88%E6%98%AF%E8%84%9A%E6%9C%AC/:6:3","tags":["node"],"title":"初识脚本","uri":"/posts/%E4%BB%80%E4%B9%88%E6%98%AF%E8%84%9A%E6%9C%AC/"},{"categories":null,"content":"简介 该简历是利用基础知识制作，主要涉及的知识点： pre标签的使用 per标签会在页面中呈现你写的内容，包括空格与换行。 pre内的标签会被当成html解析，利用此给代码高亮。 js 多行字符串使用\" ` ` “符号 字符串substring方法的使用 滚动条自动下拉倒底部：xxx.scrollTop = xxx.scrollHeight 异步与回调 两个 js 库：primjs，高亮代码；showdownjs，将 markdown 转化成 html。 ","date":"2018-08-25","objectID":"/posts/%E4%BC%9A%E5%8A%A8%E7%9A%84%E7%AE%80%E5%8E%86%E6%80%BB%E7%BB%93/:1:0","tags":["总结"],"title":"会动的简历总结","uri":"/posts/%E4%BC%9A%E5%8A%A8%E7%9A%84%E7%AE%80%E5%8E%86%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"遇到的问题 回调函数作用域问题 未解决 执行函数写在开头遇到的 substring 未定义报错 变量提升的是声明并不是赋值！ a.substring(0, 2) var a = '123456789' 等价于 var a a.substring(0, 2) a = '123456' ","date":"2018-08-25","objectID":"/posts/%E4%BC%9A%E5%8A%A8%E7%9A%84%E7%AE%80%E5%8E%86%E6%80%BB%E7%BB%93/:2:0","tags":["总结"],"title":"会动的简历总结","uri":"/posts/%E4%BC%9A%E5%8A%A8%E7%9A%84%E7%AE%80%E5%8E%86%E6%80%BB%E7%BB%93/"},{"categories":["网络"],"content":"基本概念 ","date":"2018-08-20","objectID":"/posts/http%E5%85%A5%E9%97%A8/:1:0","tags":["HTTP"],"title":"HTTP入门","uri":"/posts/http%E5%85%A5%E9%97%A8/"},{"categories":["网络"],"content":"三个基本概念 URI：统一资源资源标志符(Uniform Resource Identifier) HTTP：超文本传输协议(HyperText Transfer Protocal) HTML：超文本标记语言(HyperText Markup Language) ","date":"2018-08-20","objectID":"/posts/http%E5%85%A5%E9%97%A8/:1:1","tags":["HTTP"],"title":"HTTP入门","uri":"/posts/http%E5%85%A5%E9%97%A8/"},{"categories":["网络"],"content":"URI URI 是一个用于标识某一互联网资源名称的字符串，也就是由某个协议方案表示的资源的定位标识符。 URI 常见的两种形式： URN(Uniform Resource Name):用字符串标识某一互联网资源。ISBN: 9787115275790 就是一个 URN，通过 URN 你可以确定一个「唯一的」资源。 URL(Uniform Resource Locator）：我们一般使用 URL 作为网址，表示资源的地址。https://www.baidu.com/s?wd=hello\u0026rsv_spt=1#5 就是一个 URL，通过 URL 你可以确定一个「唯一的」地址（网址）。 其包括：协议+登录信息（可选）+域名(服务器地址)+服务器端口号+路径+查询字符串+锚点(片段标识符)： ","date":"2018-08-20","objectID":"/posts/http%E5%85%A5%E9%97%A8/:1:2","tags":["HTTP"],"title":"HTTP入门","uri":"/posts/http%E5%85%A5%E9%97%A8/"},{"categories":["网络"],"content":"DNS DNS（Domain Name System）域名系统，是一种负责域名解析协议，它提供域名到 ip 地址之间的解析服务。 使用命令行 nslookup baiducom 可以看到 baidu.com 的 ip 地址。 使用命令行ping baidu.com命令，可以查看该网址能否联通。 ","date":"2018-08-20","objectID":"/posts/http%E5%85%A5%E9%97%A8/:1:3","tags":["HTTP"],"title":"HTTP入门","uri":"/posts/http%E5%85%A5%E9%97%A8/"},{"categories":["网络"],"content":"请求与响应 ","date":"2018-08-20","objectID":"/posts/http%E5%85%A5%E9%97%A8/:2:0","tags":["HTTP"],"title":"HTTP入门","uri":"/posts/http%E5%85%A5%E9%97%A8/"},{"categories":["网络"],"content":"服务器与浏览器的交互 Server + Clilent +　HTTP 协议 浏览器负责发起请求 服务器在 80 端口接受内容 服务器返回请求的内容 HTTP 协议作用就是指导浏览器与服务器如何进行通信。 ","date":"2018-08-20","objectID":"/posts/http%E5%85%A5%E9%97%A8/:2:1","tags":["HTTP"],"title":"HTTP入门","uri":"/posts/http%E5%85%A5%E9%97%A8/"},{"categories":["网络"],"content":"HTTP 请求 请求主要由 4 部分组成： POST / HTTP/1.1 Host: www.baidu.com User-Agent: curl/7.54.0 Accept: */* Content-Type: application/x-www-form-urlencoded Content-Length: 10 请求的格式： 1 动词 路径 协议/版本 2 Key1: value1 2 Key2: value2 2 Key3: value3 2 Content-Type: application/x-www-form-urlencoded 2 Content-Length: 10 2 Host: www.baidu.com 2 User-Agent: curl/7.54.0 3 4 要上传的数据 第一部分 动词POST是一种请求方法，常见的请求方法有：GET POST PUT PATCH DELETE HEAD OPTIONS 等。 路径/，包括查询参数，但是不包括锚点。如果没有写路径则默认“/”。 HTTP/1.1指的发起请求遵循的协议与协议版本，目前主要使用 HTTP 协议。 第二部分： 第二部分内容主要是以key:calue的形式。 Host: www.baidu.com表示请求的域名 User-Agent: curl/7.54.0表示发起请求使用的软件及版本号 Accept: */*表示接收所有 Content-Length: 10表示第四部分内容的长度 Content-Type: application/x-www-form-urlencoded标注第四部分内容的格式 第三部分则是一个空行，主要作用分开第二部分与第四部分。 第四部分则是需要上传的数据。 ","date":"2018-08-20","objectID":"/posts/http%E5%85%A5%E9%97%A8/:2:2","tags":["HTTP"],"title":"HTTP入门","uri":"/posts/http%E5%85%A5%E9%97%A8/"},{"categories":["网络"],"content":"HTTP 响应 响应是对请求做出的回应，其内容格式类似请求，也主要由 4 部分组成： HTTP/1.1 302 Found Connection: Keep-Alive Content-Length: 17931 Content-Type: text/html Date: Tue, 10 Oct 2017 09:19:47 GMT Etag: “54d9749e-460b” Server: bfe/1.0.8.18 \u003chtml\u003e \u003chead\u003e \u003cmeta http-equiv=“content-type” content=“text/html;charset=utf-8”\u003e …… 响应格式： 1 协议/版本号 状态码 状态解释 2 Key1: value1 2 Key2: value2 2 Content-Length: 17931 2 Content-Type: text/html 3 4 要下载的内容 第一部分示例：HTTP/1.1 200 OK 200是一个状态码，表示响应的结果状态，后面对应的OK是状态解释。状态码以数字 1、2、3、4、5 开头，分为五种。 第二部分示例： Connection: Keep-Alive Content-Length: 17931响应第四部分内容的长度 Content-Type: text/html响应的内容格式 Date: Tue, 10 Oct 2017 09:19:47 GMT响应的时间 Etag: \"54d9749e-460b\"响应的标签 Server: bfe/1.0.8.18响应的服务器 第三部分依然是空行，分隔第二部分与第四部分 响应的内容，需要下载的内容 ","date":"2018-08-20","objectID":"/posts/http%E5%85%A5%E9%97%A8/:2:3","tags":["HTTP"],"title":"HTTP入门","uri":"/posts/http%E5%85%A5%E9%97%A8/"},{"categories":["网络"],"content":"使用 chrome 查看请求与响应 打开「Network」 地址栏输入网址 打开开发者工具 在「Network」点击，查看 request，点击「view source」 点击「view source」 点击后可以看到请求的前三部分了 如果有请求的第四部分，那么在「FormData」或「Payload」里面可以看到 ","date":"2018-08-20","objectID":"/posts/http%E5%85%A5%E9%97%A8/:2:4","tags":["HTTP"],"title":"HTTP入门","uri":"/posts/http%E5%85%A5%E9%97%A8/"},{"categories":["网络"],"content":"常见的 HTTP 状态码 1xx Informational（信息性状态码）　接受的请求正在处理 2xx Success（成功状态码）　请求正常处理完毕 200 ok 表示响应成功，从客户端发来的请求在服务器被正常处理了。 204 No Content 表示服务器接受的请求已成功处理，但没有资源返回。 206 Partial Conyent 表示客户端进行了范围请求，服务器成功执行了这部分的 GET 请求。 3xx Redirection（重定向状态码）　需要进行的附加操作以完成请求 301 Moved Permanently 表示永久性重定向，请求的资源已经被分配到新的 URI。 302 Found 表示临时性重定向，请求的资源被分配了新的 URI，希望用户此次使用新的 URI 访问。 305 Use Proxy 表示被请求的资源必须通过指定代理才能被访问。 4xx Client Error（客户端错误状态码）　服务器无法处理请求 400 Bad Request 表示请求报文中存在语法错误。 401 Unauthorized 表示发送的请求需要有通过 HTTP 认证的认证信息。 403 Forbidden 表示队请求的资源的访问被服务器拒绝了。 404 Not Found 服务器上无法找到请求的资源。 5xx Server（服务器错误状态码）　服务器处理请求出错 500 Internet Server Error 表示服务器在执行请求时发生错误。 503 Service Unavailable 表示服务器处于超负载或正在进行停机维护。 ","date":"2018-08-20","objectID":"/posts/http%E5%85%A5%E9%97%A8/:2:5","tags":["HTTP"],"title":"HTTP入门","uri":"/posts/http%E5%85%A5%E9%97%A8/"},{"categories":["网络"],"content":"使用 curl 命令发起请求 curl -s -v -H \"Frank: xxx\" -- \"https://www.baidu.com\" 使用该命令可以创造一个请求，请求访问百度。 curl -X POST -s -v -H \"Frank: xxx\" -- \"https://www.baidu.com\" 新增的-X POST表示请求的方法为 POST，没有这个则默认 GET。 curl -X POST -d \"1234567890\" -s -v -H \"Frank: xxx\" -- \"https://www.baidu.com\" 新增的 -d \"1234567890\"d 表示 date 数据，表示上传了引号中的数据。 ","date":"2018-08-20","objectID":"/posts/http%E5%85%A5%E9%97%A8/:3:0","tags":["HTTP"],"title":"HTTP入门","uri":"/posts/http%E5%85%A5%E9%97%A8/"},{"categories":null,"content":"最近装了 deepin15.6，想安装 http-server 服务，结果报错，原来是 npm 版本太老，以下罗列几种 node 安装方式，这几种方式适用 Linux/ubantu/deepin 系统。 ","date":"2018-08-16","objectID":"/posts/%E5%9C%A8deepin%E4%B8%AD%E5%AE%89%E8%A3%85node%E4%B8%8Enpm/:0:0","tags":["deepin"],"title":"在deepin中安装node与npm","uri":"/posts/%E5%9C%A8deepin%E4%B8%AD%E5%AE%89%E8%A3%85node%E4%B8%8Enpm/"},{"categories":null,"content":"1、官方途径：通过包管理器方式安装； node8 版本： curl -sL https://deb.nodesource.com/setup_8.x | sudo -E bash - sudo apt-get install -y nodejs node10 版本： curl -sL https://deb.nodesource.com/setup_10.x | sudo -E bash - sudo apt-get install -y nodejs 参考官方教程,但是很奇怪，会报错，猜测 deepin 系统的原因。 ","date":"2018-08-16","objectID":"/posts/%E5%9C%A8deepin%E4%B8%AD%E5%AE%89%E8%A3%85node%E4%B8%8Enpm/:1:0","tags":["deepin"],"title":"在deepin中安装node与npm","uri":"/posts/%E5%9C%A8deepin%E4%B8%AD%E5%AE%89%E8%A3%85node%E4%B8%8Enpm/"},{"categories":null,"content":"2、通过源码编译安装 在node 官网下载专区找到系统对应的版本，鼠标右键复制下载链接。在终端中输入： 1.下载 node wget https://nodejs.org/dist/v8.11.4/node-v8.11.4-linux-x64.tar.xz 2.解压文件 tar -xvf node-v8.11.4-linux-x64.tar.xz 3.切换并查看 node 所在路径 cd node-v8.11.4-linux-x64/bin pwd 4.查看 node 版本 node -v 5.将 node 和 npm 设置为全局(注意路径为第 3 步的路径) sudo ln /home/ubuntu/node-v8.11.4-linux-x64/bin/node /usr/local/bin/node sudo ln /home/ubuntu/node-v8.11.4-linux-x64/bin/npm /usr/local/bin/npm pwd 这种方法配置的环境容易出问题，在安装 http-server 时依然报错。 ","date":"2018-08-16","objectID":"/posts/%E5%9C%A8deepin%E4%B8%AD%E5%AE%89%E8%A3%85node%E4%B8%8Enpm/:2:0","tags":["deepin"],"title":"在deepin中安装node与npm","uri":"/posts/%E5%9C%A8deepin%E4%B8%AD%E5%AE%89%E8%A3%85node%E4%B8%8Enpm/"},{"categories":null,"content":"3、使用自带的 apt 安装 1.安装 node 与 npm sudo apt install nodejs-legacy sudo apt install npm 2.安装管理 nodejs 本身工具，n 模块 sudo npm install -g n 3.升级 node 到制定版本，后面接版本号 sudo n latest //最新版本 sudo n stable //稳定版本 sudo n lts //长期支持版本 4.升级 npm 到最新版本 sudo npm install npm@latest -g 此种方法便于管理 node 版本。 ","date":"2018-08-16","objectID":"/posts/%E5%9C%A8deepin%E4%B8%AD%E5%AE%89%E8%A3%85node%E4%B8%8Enpm/:3:0","tags":["deepin"],"title":"在deepin中安装node与npm","uri":"/posts/%E5%9C%A8deepin%E4%B8%AD%E5%AE%89%E8%A3%85node%E4%B8%8Enpm/"},{"categories":null,"content":"总结 经过测试，第三种方法在 deepin 上成功安装，目前没有遇到什么问题，推荐使用此种方法。 ","date":"2018-08-16","objectID":"/posts/%E5%9C%A8deepin%E4%B8%AD%E5%AE%89%E8%A3%85node%E4%B8%8Enpm/:4:0","tags":["deepin"],"title":"在deepin中安装node与npm","uri":"/posts/%E5%9C%A8deepin%E4%B8%AD%E5%AE%89%E8%A3%85node%E4%B8%8Enpm/"},{"categories":["JS"],"content":"js 中有 6 个基本数据类型：number、string、boolean、Symbol、null、undefined 与一个复杂的数据类型 object，object 又可以分为三个子类型：狭义的对象 object、数组 array 与函数 function。这些数据类型之间有些是可以相互转换的，然而转换前我们得知道怎么判断这些数据类型。 ","date":"2018-07-24","objectID":"/posts/js%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:0:0","tags":["JS"],"title":"js中的数据类型转换","uri":"/posts/js%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"},{"categories":["JS"],"content":"如何判断一个值的数据类型 JavaScript 有三种方法，可以确定一个值到底是什么类型。 typeof运算符 instanceof运算符 Object.prototype.toString方法 typeOf 运算符 typeOf运算符可以返回一个值的数据类型，数值、字符串、布尔值分别返回number、string、boolean，undefined返回undefined，对象返回obeject，数组[]返回object。 注意：函数则会返回function（虽然函数是个对象），null则会返回object（虽然 null 不是个对象 ，主要是为了兼容以前的代码）。 instanceof 运算符 后面补充 Object.prototype.toString 方法 后面补充 ","date":"2018-07-24","objectID":"/posts/js%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:1:0","tags":["JS"],"title":"js中的数据类型转换","uri":"/posts/js%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"},{"categories":["JS"],"content":"数据类型的转换 ","date":"2018-07-24","objectID":"/posts/js%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:2:0","tags":["JS"],"title":"js中的数据类型转换","uri":"/posts/js%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"},{"categories":["JS"],"content":"手动转换 手动转换主要有是三个方法：Number()、String()和 Boolean()三个函数，手动将各类型的值分别转换成数字、字符串和布尔值。 1.Number() 原始类型值 数值：转换后还是原来的值。 字符串：如果可以被解析为数值，则转换为相应的数值。否则，返回NaN。 空字符串会转为 0。 布尔值：true转成 1，false转成 0。 undefined：转成NaN。 null：转成 0。 对象 规则：对于对象，一般返回 NaN，但是如果是包含单个数值的数组则会返回对应的数值。 Number({ a: 1 }) // NaN Number([1, 2, 3]) // NaN Number([4]) // 4 原因解析：涉及到 Number 的转换规则。 1.调用对象自身的 typeOf方法。如果返回原始类型的值，则直接对该值使用Number函数，不再进行后续步骤。 2.如果valueOf方法返回的还是对象，则改为调用对象自身的toString方法。如果toString方法返回原始类型的值，则对该值使用Number函数，不再进行后续步骤。 3.如果toString方法返回的是对象，就报错。 var obj = { x: 1 } Number(obj) // NaN Number({}) // NaN parseInt()与 parseFloat() parseInt方法用于将字符串转为整数。 1、如果字符串头部有空格，空格会被自动去除。parseInt('123') // 123 2、如果 parseInt 的参数不是字符串，则会先转为字符串再转换。parseInt(' 81') // 81 3、如果 parseInt 的参数不是字符串，则会先转为字符串再转换。parseInt(1.23) // 1 4、字符串转为整数的时候，是一个个字符依次转换，如果遇到不能转为数字的字符，就不再进行下去，返回已经转好的部分。如果第一个便不能转化成数字，则会返回 NaN。parseInt('8a') // 8,parseInt('12.34') // 12，parseInt('abc') // NaN 5、parseInt 方法还可以接受第二个参数（2 到 36 之间），表示被解析的值的进制，返回该值对应的十进制数，默认为十进制。parseInt('1000', 2) // 8,parseInt('1000') // 1000 parseFloat方法用于将一个字符串转为浮点数。 1、如果字符串符合科学计数法，则会进行相应的转换。 2、如果字符串包含不能转为浮点数的字符，则不再进行往后转换，返回已经转好的部分。 parseFloat方法会自动过滤字符串前导的空格。 3、如果参数不是字符串，或者字符串的第一个字符不能转化为浮点数，则返回 NaN。 2. String() String方法可以将任意类型的值转化成字符串。 原始类型的值 数值、字符串、布尔值、undefined、null：转为相应的字符串。 对象 String 方法的参数如果是对象，返回一个类型字符串；如果是数组，返回该数组的字符串形式。 背后的转换规则与Number方法基本相同,只是互换了 valueOf 方法和 toString 方法的执行顺序。 String({ a: 1 }) // \"[object Object]\" 3.Boolean() Boolean函数可以将任意类型的值转为布尔值。 转换规则：除了这五个值:undefined、null、-0或0、NaN、''(空字符串)的转换结果为 false，其余的值皆为true。 Boolean(undefined) // false Boolean(null) // false Boolean(0) // false Boolean(NaN) // false Boolean('') // false Boolean({}) // true Boolean([]) // true Boolean(new Boolean(false)) // true ","date":"2018-07-24","objectID":"/posts/js%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:2:1","tags":["JS"],"title":"js中的数据类型转换","uri":"/posts/js%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"},{"categories":["JS"],"content":"自动转换 三种情况下的自动转换数据： 不同类型的数据相互运算。 123 + 'abc' // \"123abc\" 对非布尔值类型的数据求布尔值。 if ('abc') { console.log('hello') } // \"hello\" 对非数值类型的值使用一元运算符（即+和-）。 ;+{ foo: 'bar' } + // NaN 'abc' - // NaN [1, 2, 3] // NaN '1' + 0 + // 1 '1' + // 1 true // 1 '' + null // 'null' 自动转换成布尔值 JavaScript 遇到预期为布尔值的地方（比如 if 语句的条件部分），就会将非布尔值的参数自动转换为布尔值。系统内部会自动调用 Boolean 函数。 自动转换成字符串 JavaScript 遇到预期为数值的地方，就会将参数值自动转换为数值。系统内部会自动调用 Number 函数。 除了加法运算符（+）有可能把运算子转为字符串，其他运算符都会把运算子自动转成数值。 ","date":"2018-07-24","objectID":"/posts/js%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:2:2","tags":["JS"],"title":"js中的数据类型转换","uri":"/posts/js%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"},{"categories":["JS"],"content":"JS 中的数据类型一共有 7 种： 基本类型（简单类型）：数值（number）、字符串（string）、布尔值（boolean）、Symbol（ES6 种新增的一种）、null、undefined。 复杂类型（由简单类型组成）：对象（object）。 ","date":"2018-07-21","objectID":"/posts/js%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:0:0","tags":["JS"],"title":"js中的数据类型","uri":"/posts/js%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["JS"],"content":"数值（number） 整数与浮点数：JavaScript 内部，所有数字都是以 64 位浮点数形式储存。 数值精度：JavaScript 浮点数的 64 个二进制位，从最左边开始，是这样组成的。 第 1 位：符号位，0表示正数，1表示负数，决定一个数的正负。 第 2 位到第 12 位（共 11 位）：指数部分，决定数值的大小。 JavaScript 能够表示的数值范围为 2 的 1024 次方到 2 的-1023 次方（开区间），超出这个范围的数无法表示。 第 13 位到第 64 位（共 52 位）：小数部分（即有效数字），决定数值的精度。 精度最多只能到 53 个二进制位，绝对值小于等于 2 的 53 次方的整数，即-253 到 253，都可以精确表示。 数值的表示方法： 十进制：没有前导 0 的数值。 八进制：有前缀0o或0O的数值，或者有前导 0、且只用到 0-7 的八个阿拉伯数字的数值。0xff // 255 十六进制：有前缀0x或0X的数值。0o377 // 255 二进制：有前缀0b或0B的数值。0b11 // 3 科学计数法：科学计数法允许字母 e 或 E 的后面，跟着一个整数，表示这个数值的指数部分。123e3 // 12300、123e-3 // 0.123 NaN:非数字，主要出现在将字符串解析成数字出现错误的场合。5-'x' // NaN NaN 不等于任何值，包括它本身。 数值相关的方法： parseInt()将字符串转为整数，接收第二个参数(2~36)，被解析值的进制。 parseFloar()将一个字符串转为浮点数。 isNaN()判断一个值是否为 NaN。 isFinite()返回一个布尔值，判断这只是否为正常的数值。除了Infinity、-Infinity、NaN和undefined这几个值会返回false，isFinite对于其他的数值都会返回true。 ","date":"2018-07-21","objectID":"/posts/js%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:1:0","tags":["JS"],"title":"js中的数据类型","uri":"/posts/js%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["JS"],"content":"字符串（string） 字符串就是零个或多个排在一起的字符，放在单引号或双引号之中。 多行字符串实现：（字符串默认只能写在一行内。） 可以在每行末尾使用反斜杠。 使用运算符+ 运用多行注释的变通方法 ES6 中添加一个方式，键盘 1 旁边的符号包围字符串，默认单行字符串末尾有空格 var a = `1234 6789` a.lenth = 9 反斜杠（\\）转义符，在某些字符前面表示特殊含义，如\\n表示换行。 字符串可以被视为字符数组，可以使用数组的方括号运算符，用来返回某个位置的字符（位置编号从 0 开始），但是无法改变字符串。 length属性返回字符串的长度，也是无法改变的。 字符串中存在 unicod 字符时，会自动转为字面进行识别。 ","date":"2018-07-21","objectID":"/posts/js%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:2:0","tags":["JS"],"title":"js中的数据类型","uri":"/posts/js%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["JS"],"content":"布尔值、null 与 undefined 布尔值只有“真（true）”与“假（false）”两个状态。 常用操作符：\u0026\u0026与（两者均为真）;||或（其中一者为真）;！非（相反）; undefined,null,false,0,NaN,''、\"\"（空字符串）如果是布尔值会被转为false，其余都会被转为true`. 空数组（[]）、空对象（{}）对应的布尔值都是true. null 和 undefined 很相似，都可以表示“没有” 区别： a. 变量没有赋值—-undefined。 b. 有一个对象 object，不想赋值—-null。 有一个非对象，不想赋值—-undefined（这两个是推荐用法，惯例）。 null表示“空值”，undefined表示“未定义”。 ","date":"2018-07-21","objectID":"/posts/js%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:3:0","tags":["JS"],"title":"js中的数据类型","uri":"/posts/js%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["JS"],"content":"对象（object） 对象是一组“键名-键值对”（key-value）的集合，是一种无序的复合数据集合，可以理解为哈希表。{'key':'value','key':'value','key':'value',·······} 键名与键值： 键名是数值则会自动转为字符串 如果键名不符合标识名的条件（比如第一个字符为数字，或者含有空格或运算符），且也不是数字，则必须加上引号，否则会报错。 对象的每一个键名又称为“属性”（property），它的“键值”可以是任何数据 属性的相关操作： 读取：两种方法： a.点运算符obj.p，数字键不能使用点运算符。 b.方括号运算符obj['p']。 方括号内部可以使用表达式。 数字键不加引号会自动转成字符串。 赋值：obj.foo = 'hello',obj['foo'] = 'hello'。 查看：使用Object.keys查看一个对象本身的所有属性。 删除：使用delete命令即可删除一个属性，delete pbj.p // true,删除成功返回 true。 属性是否存在： in运算符。'toString' in obj，但是不能识别哪些属性是对象自身的，哪些属性是继承的。利用 hasOwnPorperty 方法判断，是否为自身属性。 属性遍历：利用for...in循环。 它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性。 它不仅遍历对象自身的属性，还遍历继承的属性。 with 语句：格式如下： js with (对象){ 语句; } 作用：操作同一个对象的多个属性时，提供一些书写的方便。（少用） ","date":"2018-07-21","objectID":"/posts/js%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:4:0","tags":["JS"],"title":"js中的数据类型","uri":"/posts/js%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["Web"],"content":"HTML 常用标签 HTML 常用标签有：a、form、input、button、h1、p、ul、ol、small、strong、div、span、kbd、video、audio、svg 等等。 ","date":"2018-07-05","objectID":"/posts/%E6%B5%85%E8%B0%88htnl%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:0:0","tags":["HTML"],"title":"浅谈HTNL常用标签","uri":"/posts/%E6%B5%85%E8%B0%88htnl%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":["Web"],"content":"组成文档结构的标签 主要用来构成整个文档大概的框架：\u003chead\u003e、\u003ctitle\u003e、\u003cbody\u003e、\u003ch1\u003e、\u003cp\u003e、\u003cul\u003e、\u003col\u003e、\u003col\u003e、\u003cli\u003e、\u003cdiv\u003e、\u003cspan\u003e等等。 \u003chead\u003e、\u003cbody\u003e标签 组成整个页面的头和身体，大部分内容放在\u003cbody\u003e中，\u003chead\u003e中有一般只有一个标题\u003ctitle\u003e。 \u003ch1\u003e标题标签， 一共有 6 个从\u003ch1\u003e~\u003ch6\u003e，对应着 6 级标题，反正够你用了。 其中\u003ch1\u003e~\u003ch3\u003e对浏览器友好，意思就是这三个标题能够更容易被浏览器搜索到。 \u003cp\u003e段落标签（paragraph） 用来标识一段段落的。 \u003cdiv\u003e盒标签（盒模型） 我们常说的盒模型就指的\u003cdiv\u003e，主要作用就是把页面划分成一块一块，就像一个盒子般，里面嵌套其它内容。 \u003cspan\u003e块标签 作用类似于\u003cdiv\u003e，但是\u003cspan\u003e是把一行里面的内容分块。 \u003cul\u003e、\u003col\u003e、\u003cli\u003e列表标签 \u003cul\u003e或\u003col\u003e包含几个\u003cli\u003e组成一个列表。 \u003cul\u003e(unordered list)无序列表，展现的列表是无序的，\u003cli\u003e前面一般是一个标志。而\u003col\u003e(ordered list)是有序列表，\u003cli\u003e前面会自动排序。 ","date":"2018-07-05","objectID":"/posts/%E6%B5%85%E8%B0%88htnl%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:1:0","tags":["HTML"],"title":"浅谈HTNL常用标签","uri":"/posts/%E6%B5%85%E8%B0%88htnl%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":["Web"],"content":"多媒体嵌入 主要用来插入一些多媒体内容：\u003cimg\u003e、\u003cvideo\u003e、\u003caudio\u003e、\u003cifram\u003e、\u003csvg\u003e。 \u003cimg\u003e插入图片 src图片的来源。 alt图片无法正常加载时显示的内容。 title鼠标悬停在图片上显示的内容。 \u003cvideo\u003e插入视屏、\u003caudio\u003e插入音频 src视屏来源 \u003cifram\u003e插入网页（少用） \u003csvg\u003e插入画板 ","date":"2018-07-05","objectID":"/posts/%E6%B5%85%E8%B0%88htnl%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:2:0","tags":["HTML"],"title":"浅谈HTNL常用标签","uri":"/posts/%E6%B5%85%E8%B0%88htnl%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":["Web"],"content":"文本内容修饰的标签 主要用来修饰文本内容：\u003ca\u003e、\u003csmall\u003e、\u003cstrong\u003e、\u003cem\u003e等等 \u003ca\u003e（anchor 锚点）超链接标签（使用 GET 方法跳转页面） 可以创建一个到其他网页、文件、同一页面内的位置、电子邮件地址或任何其他 URL 的超链接。 _ href 属性： 如果指向域名则跳转对应的域名(http://qq.com) ，如果指向文件（http 中存在 Content-Type：application）则下载文件。（不支持 file 协议）。 #锚点，页面跳转后不发起请求，跳转到顶部。 伪协议：后接一段 JavaScript 代码，直接实现代码。javascript: alert('1')弹出对话框 1，javascript: ;点击后什么都不做。 _ target 属性： 1. “_blank” 在新页面打开 2. “_self” 在当前页面打开 3. “_parent” 当存在\u003cifram\u003e时会在父页面打开 4. “_top\"当存在多个\u003cifram\u003e（≥3）时，会在最外层页面打开 * download 属性：表示 a 标签不再跳转链接，而是强制下载文件，href 是域名则下载网页。 \u003cstrong\u003e加粗标签 表示文本十分重要，一般用粗体显示。不同于\u003cb\u003e标签（同样加粗文本），\u003cstrong\u003e强调内容与形式，内容很重要，而\u003cb\u003e强调形式。 \u003csmall\u003e缩小标签 使文本的字体变小一号，一般被定义为表示边注释和附属细则。 \u003cem\u003e斜体标签 使文本内容变成斜体，标记出需要用户着重阅读的内容。与\u003cstrong\u003e类似，\u003cem\u003e也有一个\u003ci\u003e标签表示斜体。同样的，\u003cem\u003e强调内容与形式，内容很重要，而\u003ci\u003e强调形式。 ","date":"2018-07-05","objectID":"/posts/%E6%B5%85%E8%B0%88htnl%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:3:0","tags":["HTML"],"title":"浅谈HTNL常用标签","uri":"/posts/%E6%B5%85%E8%B0%88htnl%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":["Web"],"content":"HTML 表单 常用来提交内容：\u003cform\u003e、\u003cinput\u003e、\u003cbutton\u003e、\u003clabel\u003e \u003cform\u003e主要用来提交内容(使用 POST 方法跳转页面，提交的内容放在请求的第四部分) action 属性：发起请求后跳转的页面。 method=\"post\"（默认为 GET）使用 POST 发起请求。 target同\u003ca\u003e标签 \u003cinput\u003e标签 type=\"submit\"：提交按钮（如果\u003cform\u003e没有 submit 则无法提交） 如果一个只有一个按钮\u003cbutton\u003e，会自动升级为提交按钮。 如果该标签明确定义 type=“button”，则不会升级，依然为按钮。 type=\"checkbox\"多选框\u003ctype=“radio”\u003e单选框 两者均必须使用 value 属性定义此控件被提交时的值，使用 checked 属性指示控件是否被选择。 \u003clabel\u003e标签：通常将按钮囊括在里面，点击囊括在内的任何区域都视为被选择。 \u003clabel\u003e\u003cinput type=\"checkbox\"\u003e爱我\u003c/label\u003e当点击爱我时，没有点击按钮，也会被视为被选中了。 也可以把\u003clabel\u003e放在里面将内容囊括起来，利用 for 属性与 id 属性达到同样的效果. \u003cinput type=\"checkbox\" id=\"xxxx\"\u003e\u003clabel for=\"xxx\"\u003e爱我\u003c/label\u003e type=\"select\"下拉菜单选择 \u003coption\u003e标签下拉菜单的选项，select属性表示默认选择，disabled表示不可选中。 mutiple属性表示多选 type=\"textarea\"输入文本框 resize:none文本框默认宽高不固定，该属性表示固定宽高。一般利用 css 固定宽高。 height: 100; width: 200;设定文本框宽高，一般利用 css 固定宽高。 rows:10文本框输入的内容设定的行数。 ","date":"2018-07-05","objectID":"/posts/%E6%B5%85%E8%B0%88htnl%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:4:0","tags":["HTML"],"title":"浅谈HTNL常用标签","uri":"/posts/%E6%B5%85%E8%B0%88htnl%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":["Web"],"content":"HTML 表格 常用来表示数据（少用）：\u003ctable\u003e标签里只能有以下标签 \u003cthead\u003e表头\u003e\u003ctr\u003e行（table row）\u003e\u003cth\u003e标题单元格 \u003ctbody\u003e表格\u003e\u003ctr\u003e行\u003e\u003ctd\u003e单元格（table data） \u003ctfoot\u003e表注 ","date":"2018-07-05","objectID":"/posts/%E6%B5%85%E8%B0%88htnl%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:5:0","tags":["HTML"],"title":"浅谈HTNL常用标签","uri":"/posts/%E6%B5%85%E8%B0%88htnl%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":null,"content":"离线 - Xiaomu","date":"0001-01-01","objectID":"/offline/","tags":null,"title":"","uri":"/offline/"}]